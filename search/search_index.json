{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"rio-tiler \u00b6 Rasterio plugin to read mercator tiles from Cloud Optimized GeoTIFF. Documentation : cogeotiff.github.io/rio-tiler/ Source Code : cogeotiff/rio-tiler Install \u00b6 You can install rio-tiler using pip $ pip install -U pip $ pip install rio-tiler --pre # version 2.0 is in development or install from source: $ git clone https://github.com/cogeotiff/rio-tiler.git $ cd rio-tiler $ pip install -U pip $ pip install -e . Partial reading on Cloud hosted dataset \u00b6 Rio-tiler perform partial reading on local or distant dataset, which is why it will perform best on Cloud Optimized GeoTIFF (COG). It's important to note that Sentinel-2 scenes hosted on AWS are not in Cloud Optimized format but in JPEG2000 . When performing partial reading of JPEG2000 dataset GDAL (rasterio backend library) will need to make a lot of GET requests and transfer a lot of data. Ref: Do you really want people using your data blog post. Plugins \u00b6 rio-tiler-crs : Create Map Tiles using other TileMatrixSets rio-tiler-mvt : Create Mapbox Vector Tile from numpy array (tile/mask) Mission Specific tiler In rio-tiler v2 we choosed to remove the mission specific tilers (Sentinel2, Sentinel1, Landsat8 and CBERS). Those are now in a specific plugin: rio-tiler-pds . Implementations \u00b6 rio-viz : Visualize Cloud Optimized GeoTIFF in browser locally titiler CosmiQ/solaris cogeo-tiler Contribution & Development \u00b6 See CONTRIBUTING.md Authors \u00b6 The rio-tiler project was begun at Mapbox and has been transferred in January 2019. See AUTHORS.txt for a listing of individual contributors. Changes \u00b6 See CHANGES.md . License \u00b6 See LICENSE.txt","title":"Home"},{"location":"#rio-tiler","text":"Rasterio plugin to read mercator tiles from Cloud Optimized GeoTIFF. Documentation : cogeotiff.github.io/rio-tiler/ Source Code : cogeotiff/rio-tiler","title":"rio-tiler"},{"location":"#install","text":"You can install rio-tiler using pip $ pip install -U pip $ pip install rio-tiler --pre # version 2.0 is in development or install from source: $ git clone https://github.com/cogeotiff/rio-tiler.git $ cd rio-tiler $ pip install -U pip $ pip install -e .","title":"Install"},{"location":"#partial-reading-on-cloud-hosted-dataset","text":"Rio-tiler perform partial reading on local or distant dataset, which is why it will perform best on Cloud Optimized GeoTIFF (COG). It's important to note that Sentinel-2 scenes hosted on AWS are not in Cloud Optimized format but in JPEG2000 . When performing partial reading of JPEG2000 dataset GDAL (rasterio backend library) will need to make a lot of GET requests and transfer a lot of data. Ref: Do you really want people using your data blog post.","title":"Partial reading on Cloud hosted dataset"},{"location":"#plugins","text":"rio-tiler-crs : Create Map Tiles using other TileMatrixSets rio-tiler-mvt : Create Mapbox Vector Tile from numpy array (tile/mask) Mission Specific tiler In rio-tiler v2 we choosed to remove the mission specific tilers (Sentinel2, Sentinel1, Landsat8 and CBERS). Those are now in a specific plugin: rio-tiler-pds .","title":"Plugins"},{"location":"#implementations","text":"rio-viz : Visualize Cloud Optimized GeoTIFF in browser locally titiler CosmiQ/solaris cogeo-tiler","title":"Implementations"},{"location":"#contribution-development","text":"See CONTRIBUTING.md","title":"Contribution &amp; Development"},{"location":"#authors","text":"The rio-tiler project was begun at Mapbox and has been transferred in January 2019. See AUTHORS.txt for a listing of individual contributors.","title":"Authors"},{"location":"#changes","text":"See CHANGES.md .","title":"Changes"},{"location":"#license","text":"See LICENSE.txt","title":"License"},{"location":"colormap/","text":"Colormaps \u00b6 Rio-tiler includes many colormaps, some derived from Matplotlib and some custom ones that are commonly used with raster data. You can load a colormap with rio_tiler.colormap.get_colormap , and then pass it to rio_tiler.utils.render : from rio_tiler.colormap import cmap from rio_tiler.utils import render colormap = cmap . get ( 'cfastie' ) render ( tile , mask , colormap = colormap ) References \u00b6 Matplotlib colormaps: matplotlib.org/3.1.0/tutorials/colors/colormaps.html cfastie : publiclab.org/notes/cfastie/08-26-2014/new-ndvi-colormap rplumbo : cogeotiff/rio-tiler!90 schwarzwald : soliton.vm.bytemark.co.uk/pub/cpt-city/wkp/schwarzwald/tn/wiki-schwarzwald-cont.png.index.html Update images for new colormaps \u00b6 To regenerate these images for new colormaps, update the list of colormaps at the top of scripts/colormap_thumb.py and then run python scripts/colormap_thumb.py","title":"Colormaps"},{"location":"colormap/#colormaps","text":"Rio-tiler includes many colormaps, some derived from Matplotlib and some custom ones that are commonly used with raster data. You can load a colormap with rio_tiler.colormap.get_colormap , and then pass it to rio_tiler.utils.render : from rio_tiler.colormap import cmap from rio_tiler.utils import render colormap = cmap . get ( 'cfastie' ) render ( tile , mask , colormap = colormap )","title":"Colormaps"},{"location":"colormap/#references","text":"Matplotlib colormaps: matplotlib.org/3.1.0/tutorials/colors/colormaps.html cfastie : publiclab.org/notes/cfastie/08-26-2014/new-ndvi-colormap rplumbo : cogeotiff/rio-tiler!90 schwarzwald : soliton.vm.bytemark.co.uk/pub/cpt-city/wkp/schwarzwald/tn/wiki-schwarzwald-cont.png.index.html","title":"References"},{"location":"colormap/#update-images-for-new-colormaps","text":"To regenerate these images for new colormaps, update the list of colormaps at the top of scripts/colormap_thumb.py and then run python scripts/colormap_thumb.py","title":"Update images for new colormaps"},{"location":"contributing/","text":"Contributing \u00b6 Issues and pull requests are more than welcome. dev install $ git clone https://github.com/cogeotiff/rio-tiler.git $ cd rio-tiler $ pip install -e . [ dev ] Python3.7 only This repo is set to use pre-commit to run isort , flake8 , pydocstring , black (\"uncompromising Python code formatter\") and mypy when committing new code. $ pre-commit install Docs \u00b6 $ git clone https://github.com/cogeotiff/rio-tiler.git $ cd rio-cogeo $ pip install -e . [ \"docs\" ] Hot-reloading docs: $ mkdocs serve To manually deploy docs (note you should never need to do this because Github Actions deploys automatically for new commits.): $ mkdocs gh-deploy","title":"Development - Contributing"},{"location":"contributing/#contributing","text":"Issues and pull requests are more than welcome. dev install $ git clone https://github.com/cogeotiff/rio-tiler.git $ cd rio-tiler $ pip install -e . [ dev ] Python3.7 only This repo is set to use pre-commit to run isort , flake8 , pydocstring , black (\"uncompromising Python code formatter\") and mypy when committing new code. $ pre-commit install","title":"Contributing"},{"location":"contributing/#docs","text":"$ git clone https://github.com/cogeotiff/rio-tiler.git $ cd rio-cogeo $ pip install -e . [ \"docs\" ] Hot-reloading docs: $ mkdocs serve To manually deploy docs (note you should never need to do this because Github Actions deploys automatically for new commits.): $ mkdocs gh-deploy","title":"Docs"},{"location":"intro/","text":"Usage \u00b6 The rio_tiler module can create mercator tiles from any raster source supported by Rasterio/GDAL (i.e. local files, http, s3, gcs etc.). Additional method are availables (see COGReader ) Read a tile from a file \u00b6 from rio_tiler.io import COGReader with COGReader ( \"http://oin-hotosm.s3.amazonaws.com/5a95f32c2553e6000ce5ad2e/0/10edab38-1bdd-4c06-b83d-6e10ac532b7d.tif\" ) as cog : tile , mask = cog . tile ( 691559 , 956905 , 21 , tilesize = 256 ) print ( tile . shape ) > ( 3 , 256 , 256 ) print ( mask . shape ) > ( 256 , 256 ) Render the array as an image (PNG/JPEG) \u00b6 from rio_tiler.utils import render buffer = render ( tile , mask = mask ) # this returns a buffer (PNG by default) Rescale non-byte data and/or apply colormap from rio_tiler.colormap import cmap from rio_tiler.utils import linear_rescale # Rescale the tile array only where mask is valid and cast it to byte tile = numpy . where ( mask , linear_rescale ( tile , in_range = ( 0 , 1000 ), out_range = [ 0 , 255 ]), 0 ) . astype ( numpy . uint8 ) cm = cmap . get ( \"viridis\" ) buffer = render ( tile , mask = mask , colormap = cm ) Use creation options to match mapnik defaults. from rio_tiler.utils import render from rio_tiler.profiles import img_profiles options = img_profiles . get ( \"webp\" ) buffer = render ( tile , mask = mask , img_format = \"webp\" , ** options ) Write image to file with open ( \"my.png\" , \"wb\" ) as f : f . write ( buffer ) NumpyTile \u00b6 You can also export image data to a numpy binary format ( NPY ) from io import BytesIO import numpy from rio_tiler.utils import render buffer = render ( tile , mask = mask , img_format = \"npy\" ) npy_tile = numpy . load ( BytesIO ( buffer )) assert npy_tile . shape == ( 4 , 256 , 256 ) # mask is appened to the end of the data","title":"Intro"},{"location":"intro/#usage","text":"The rio_tiler module can create mercator tiles from any raster source supported by Rasterio/GDAL (i.e. local files, http, s3, gcs etc.). Additional method are availables (see COGReader )","title":"Usage"},{"location":"intro/#read-a-tile-from-a-file","text":"from rio_tiler.io import COGReader with COGReader ( \"http://oin-hotosm.s3.amazonaws.com/5a95f32c2553e6000ce5ad2e/0/10edab38-1bdd-4c06-b83d-6e10ac532b7d.tif\" ) as cog : tile , mask = cog . tile ( 691559 , 956905 , 21 , tilesize = 256 ) print ( tile . shape ) > ( 3 , 256 , 256 ) print ( mask . shape ) > ( 256 , 256 )","title":"Read a tile from a file"},{"location":"intro/#render-the-array-as-an-image-pngjpeg","text":"from rio_tiler.utils import render buffer = render ( tile , mask = mask ) # this returns a buffer (PNG by default) Rescale non-byte data and/or apply colormap from rio_tiler.colormap import cmap from rio_tiler.utils import linear_rescale # Rescale the tile array only where mask is valid and cast it to byte tile = numpy . where ( mask , linear_rescale ( tile , in_range = ( 0 , 1000 ), out_range = [ 0 , 255 ]), 0 ) . astype ( numpy . uint8 ) cm = cmap . get ( \"viridis\" ) buffer = render ( tile , mask = mask , colormap = cm ) Use creation options to match mapnik defaults. from rio_tiler.utils import render from rio_tiler.profiles import img_profiles options = img_profiles . get ( \"webp\" ) buffer = render ( tile , mask = mask , img_format = \"webp\" , ** options ) Write image to file with open ( \"my.png\" , \"wb\" ) as f : f . write ( buffer )","title":"Render the array as an image (PNG/JPEG)"},{"location":"intro/#numpytile","text":"You can also export image data to a numpy binary format ( NPY ) from io import BytesIO import numpy from rio_tiler.utils import render buffer = render ( tile , mask = mask , img_format = \"npy\" ) npy_tile = numpy . load ( BytesIO ( buffer )) assert npy_tile . shape == ( 4 , 256 , 256 ) # mask is appened to the end of the data","title":"NumpyTile"},{"location":"mosaic/","text":"Using rio-tiler with Mosaics \u00b6 The rio-tiler-mosaic library has been moved into rio-tiler . The goal of the rio_tiler.mosaic module is to create a mercator tile from multiple observations. This is useful when a source image doesn't fill the entire mercator tile of interest. Often when creating a mercator tile from multiple assets, there will be portions of overlap where a pixel could be chosen from multiple datasets. To handle this, the rio-tiler.mosaic module provides pixel selection methods which define how to handle these cases for each pixel: First : select value from the first non-missing asset Highest : loop though all the assets and return the highest value Lowest : loop though all the assets and return the lowest value Mean : compute the mean value of the whole stack Median : compute the median value of the whole stack API \u00b6 rio_tiler.mosaic.mosaic_reader(assets, tiler, *args* pixel_selection=None, chunk_size=None, Threads=10, **kwargs) Inputs: assets : list, tuple of rio-tiler compatible assets (url or sceneid) tiler: Callable that returns a tuple of numpy.array (e.g tile, mask = rio_tiler.reader.tile(x, y, z, **kwargs) ) *args: tiler specific arguments. pixel_selection : optional pixel selection algorithm (default: \"first\"). chunk_size: optional, control the number of asset to process per loop. **kwargs: tiler specific keyword arguments. Returns: - (tile, mask), assets_used : tuple of ndarray Return (tile and mask) data and the list of used assets. Examples \u00b6 from rio_tiler.io import COGReader from rio_tiler.mosaic import mosaic_reader from rio_tiler.mosaic.methods import defaults def tiler ( src_path : str , * args , ** kwargs ) -> Tuple [ numpy . ndarray , numpy . ndarray ]: with COGReader ( src_path ) as cog : return cog . tile ( * args , ** kwargs ) assets = [ \"mytif1.tif\" , \"mytif2.tif\" , \"mytif3.tif\" ] tile = ( 1000 , 1000 , 9 ) x , y , z = tile # Use Default First value method mosaic_reader ( assets , tiler , x , y , z ) # Use Highest value: defaults.HighestMethod() mosaic_reader ( assets , tiler , x , y , z , pixel_selection = defaults . HighestMethod () ) # Use Lowest value: defaults.LowestMethod() mosaic_reader ( assets , tiler , x , y , z , pixel_selection = defaults . LowestMethod () ) The MosaicMethod interface \u00b6 the rio_tiler.mosaic.methods.base.MosaicMethodBase class defines an abstract interface for all pixel selection methods allowed by rio_tiler.mosaic.mosaic_reader . its methods and properties are: is_done : property, returns a boolean indicating if the process is done filling the tile data : property, returns the output tile and mask numpy arrays feed(tile: numpy.ma.ndarray) : method, update the tile The MosaicMethodBase class is not intended to be used directly but as an abstract base class, a template for concrete implementations. Writing your own Pixel Selection method \u00b6 The rules for writing your own pixel selection algorithm class are as follows: Must inherit from MosaicMethodBase Must provide concrete implementations of all the above methods. See rio_tiler.mosaic.methods.defaults classes for examples. Smart Multi-Threading \u00b6 When dealing with an important number of image, you might not want to process the whole stack, especially if the pixel selection method stops when the tile is filled. To allow better optimization, rio_tiler.mosaic.mosaic_reader is fetching the tiles in parallel (threads) but to limit the number of files we also embeded the fetching in a loop (creating 2 level of processing): assets = [ \"1.tif\" , \"2.tif\" , \"3.tif\" , \"4.tif\" , \"5.tif\" , \"6.tif\" ] # 1st level loop - Creates chuncks of assets for chunks in _chunks ( assets , chunk_size ): # 2nd level loop - Uses threads for process each `chunck` with futures . ThreadPoolExecutor ( max_workers = max_threads ) as executor : future_tasks = [( executor . submit ( _tiler , asset ), asset ) for asset in chunks ] By default the chunck_size is equal to the number or threads (or the number of assets if no threads=0) More on threading \u00b6 The number of threads used can be set in the function call with the threads= options. By default it will be equal to multiprocessing.cpu_count() * 5 or to the MAX_THREADS environment variable. In some case, threading can slow down your application. You can set threads to 0 or 1 to run the tiler in a loop without using a ThreadPool. Benchmark: --------------------------------- benchmark '1images': 6 tests --------------------------------- Name (time in ms) Min Max Mean Median ------------------------------------------------------------------------------------------------ 1images-0threads 64.3108 (1.0) 66.9192 (1.0) 65.0202 (1.0) 64.9370 (1.0) 1images-4threads 69.0893 (1.07) 70.9919 (1.06) 69.6718 (1.07) 69.5102 (1.07) 1images-1threads 69.4884 (1.08) 71.8967 (1.07) 70.0853 (1.08) 69.9804 (1.08) 1images-5threads 69.5552 (1.08) 75.5498 (1.13) 71.7882 (1.10) 70.9849 (1.09) 1images-3threads 69.7684 (1.08) 74.4098 (1.11) 70.6282 (1.09) 70.2353 (1.08) 1images-2threads 69.9258 (1.09) 73.8798 (1.10) 70.8861 (1.09) 70.3682 (1.08) ------------------------------------------------------------------------------------------------ ----------------------------------- benchmark '5images': 6 tests ----------------------------------- Name (time in ms) Min Max Mean Median ---------------------------------------------------------------------------------------------------- 5images-5threads 104.1609 (1.0) 123.4442 (1.0) 110.4130 (1.0) 110.0683 (1.0) 5images-4threads 160.0952 (1.54) 170.7994 (1.38) 163.6062 (1.48) 161.8923 (1.47) 5images-3threads 161.2354 (1.55) 172.0363 (1.39) 165.1222 (1.50) 164.6513 (1.50) 5images-2threads 214.2413 (2.06) 220.7737 (1.79) 217.7740 (1.97) 217.9166 (1.98) 5images-0threads 228.2062 (2.19) 242.9397 (1.97) 231.9848 (2.10) 229.2843 (2.08) 5images-1threads 248.6630 (2.39) 251.8809 (2.04) 250.5195 (2.27) 251.2667 (2.28) ---------------------------------------------------------------------------------------------------- ref: github.com/cogeotiff/rio-tiler/issues/207#issuecomment-665958838 As mentioned in #207, using ThreadPool with 1 thread is always slower than not using thread.","title":"Mosaic"},{"location":"mosaic/#using-rio-tiler-with-mosaics","text":"The rio-tiler-mosaic library has been moved into rio-tiler . The goal of the rio_tiler.mosaic module is to create a mercator tile from multiple observations. This is useful when a source image doesn't fill the entire mercator tile of interest. Often when creating a mercator tile from multiple assets, there will be portions of overlap where a pixel could be chosen from multiple datasets. To handle this, the rio-tiler.mosaic module provides pixel selection methods which define how to handle these cases for each pixel: First : select value from the first non-missing asset Highest : loop though all the assets and return the highest value Lowest : loop though all the assets and return the lowest value Mean : compute the mean value of the whole stack Median : compute the median value of the whole stack","title":"Using rio-tiler with Mosaics"},{"location":"mosaic/#api","text":"rio_tiler.mosaic.mosaic_reader(assets, tiler, *args* pixel_selection=None, chunk_size=None, Threads=10, **kwargs) Inputs: assets : list, tuple of rio-tiler compatible assets (url or sceneid) tiler: Callable that returns a tuple of numpy.array (e.g tile, mask = rio_tiler.reader.tile(x, y, z, **kwargs) ) *args: tiler specific arguments. pixel_selection : optional pixel selection algorithm (default: \"first\"). chunk_size: optional, control the number of asset to process per loop. **kwargs: tiler specific keyword arguments. Returns: - (tile, mask), assets_used : tuple of ndarray Return (tile and mask) data and the list of used assets.","title":"API"},{"location":"mosaic/#examples","text":"from rio_tiler.io import COGReader from rio_tiler.mosaic import mosaic_reader from rio_tiler.mosaic.methods import defaults def tiler ( src_path : str , * args , ** kwargs ) -> Tuple [ numpy . ndarray , numpy . ndarray ]: with COGReader ( src_path ) as cog : return cog . tile ( * args , ** kwargs ) assets = [ \"mytif1.tif\" , \"mytif2.tif\" , \"mytif3.tif\" ] tile = ( 1000 , 1000 , 9 ) x , y , z = tile # Use Default First value method mosaic_reader ( assets , tiler , x , y , z ) # Use Highest value: defaults.HighestMethod() mosaic_reader ( assets , tiler , x , y , z , pixel_selection = defaults . HighestMethod () ) # Use Lowest value: defaults.LowestMethod() mosaic_reader ( assets , tiler , x , y , z , pixel_selection = defaults . LowestMethod () )","title":"Examples"},{"location":"mosaic/#the-mosaicmethod-interface","text":"the rio_tiler.mosaic.methods.base.MosaicMethodBase class defines an abstract interface for all pixel selection methods allowed by rio_tiler.mosaic.mosaic_reader . its methods and properties are: is_done : property, returns a boolean indicating if the process is done filling the tile data : property, returns the output tile and mask numpy arrays feed(tile: numpy.ma.ndarray) : method, update the tile The MosaicMethodBase class is not intended to be used directly but as an abstract base class, a template for concrete implementations.","title":"The MosaicMethod interface"},{"location":"mosaic/#writing-your-own-pixel-selection-method","text":"The rules for writing your own pixel selection algorithm class are as follows: Must inherit from MosaicMethodBase Must provide concrete implementations of all the above methods. See rio_tiler.mosaic.methods.defaults classes for examples.","title":"Writing your own Pixel Selection method"},{"location":"mosaic/#smart-multi-threading","text":"When dealing with an important number of image, you might not want to process the whole stack, especially if the pixel selection method stops when the tile is filled. To allow better optimization, rio_tiler.mosaic.mosaic_reader is fetching the tiles in parallel (threads) but to limit the number of files we also embeded the fetching in a loop (creating 2 level of processing): assets = [ \"1.tif\" , \"2.tif\" , \"3.tif\" , \"4.tif\" , \"5.tif\" , \"6.tif\" ] # 1st level loop - Creates chuncks of assets for chunks in _chunks ( assets , chunk_size ): # 2nd level loop - Uses threads for process each `chunck` with futures . ThreadPoolExecutor ( max_workers = max_threads ) as executor : future_tasks = [( executor . submit ( _tiler , asset ), asset ) for asset in chunks ] By default the chunck_size is equal to the number or threads (or the number of assets if no threads=0)","title":"Smart Multi-Threading"},{"location":"mosaic/#more-on-threading","text":"The number of threads used can be set in the function call with the threads= options. By default it will be equal to multiprocessing.cpu_count() * 5 or to the MAX_THREADS environment variable. In some case, threading can slow down your application. You can set threads to 0 or 1 to run the tiler in a loop without using a ThreadPool. Benchmark: --------------------------------- benchmark '1images': 6 tests --------------------------------- Name (time in ms) Min Max Mean Median ------------------------------------------------------------------------------------------------ 1images-0threads 64.3108 (1.0) 66.9192 (1.0) 65.0202 (1.0) 64.9370 (1.0) 1images-4threads 69.0893 (1.07) 70.9919 (1.06) 69.6718 (1.07) 69.5102 (1.07) 1images-1threads 69.4884 (1.08) 71.8967 (1.07) 70.0853 (1.08) 69.9804 (1.08) 1images-5threads 69.5552 (1.08) 75.5498 (1.13) 71.7882 (1.10) 70.9849 (1.09) 1images-3threads 69.7684 (1.08) 74.4098 (1.11) 70.6282 (1.09) 70.2353 (1.08) 1images-2threads 69.9258 (1.09) 73.8798 (1.10) 70.8861 (1.09) 70.3682 (1.08) ------------------------------------------------------------------------------------------------ ----------------------------------- benchmark '5images': 6 tests ----------------------------------- Name (time in ms) Min Max Mean Median ---------------------------------------------------------------------------------------------------- 5images-5threads 104.1609 (1.0) 123.4442 (1.0) 110.4130 (1.0) 110.0683 (1.0) 5images-4threads 160.0952 (1.54) 170.7994 (1.38) 163.6062 (1.48) 161.8923 (1.47) 5images-3threads 161.2354 (1.55) 172.0363 (1.39) 165.1222 (1.50) 164.6513 (1.50) 5images-2threads 214.2413 (2.06) 220.7737 (1.79) 217.7740 (1.97) 217.9166 (1.98) 5images-0threads 228.2062 (2.19) 242.9397 (1.97) 231.9848 (2.10) 229.2843 (2.08) 5images-1threads 248.6630 (2.39) 251.8809 (2.04) 250.5195 (2.27) 251.2667 (2.28) ---------------------------------------------------------------------------------------------------- ref: github.com/cogeotiff/rio-tiler/issues/207#issuecomment-665958838 As mentioned in #207, using ThreadPool with 1 thread is always slower than not using thread.","title":"More on threading"},{"location":"readers/","text":"COGReader \u00b6 class COGReader : \"\"\" Cloud Optimized GeoTIFF Reader. Examples -------- with COGReader(src_path) as cog: cog.tile(...) # Set global options with COGReader(src_path, unscale=True, nodata=0) as cog: cog.tile(...) with rasterio.open(src_path) as src_dst: with WarpedVRT(src_dst, ...) as vrt_dst: with COGReader(None, dataset=vrt_dst) as cog: cog.tile(...) with rasterio.open(src_path) as src_dst: with COGReader(None, dataset=src_dst) as cog: cog.tile(...) Attributes ---------- filepath: str Cloud Optimized GeoTIFF path. dataset: rasterio.DatasetReader, optional Rasterio dataset. Properties ---------- minzoom: int COG minimum zoom level. maxzoom: int COG maximum zoom level. bounds: tuple[float] COG bounds in WGS84 crs. center: tuple[float, float, int] COG center + minzoom colormap: dict COG internal colormap. Methods ------- tile(0, 0, 0, indexes=(1,2,3), expression=\"\u001dB1/B2\", tilesize=512, resampling_methods=\"nearest\") Read a map tile from the COG. part((0,10,0,10), indexes=(1,2,3,), expression=\"\u001dB1/B20\", max_size=1024) Read part of the COG. preview(max_size=1024) Read preview of the COG. point((10, 10), indexes=1) Read a point value from the COG. info: dict General information about the COG (datatype, indexes, ...) stats(pmin=5, pmax=95) Get Raster statistics. meta(pmin=5, pmax=95) Get info + raster statistics \"\"\" Properties \u00b6 dataset : Return the rasterio dataset colormap : Return the dataset's internal colormap minzoom : Return minimum Mercator Zoom maxzoom : Return maximum Mercator Zoom bounds : Return the dataset bounds in WGS84 center : Return the center of the dataset + minzoom spatial_info : Return the bounds, center and zoom infos Methods \u00b6 tile() : Read map tile from a raster with COGReader ( \"myfile.tif\" ) as cog : tile , mask = cog . tile ( 1 , 2 , 3 , tilesize = 256 ) # With indexes with COGReader ( \"myfile.tif\" ) as cog : tile , mask = cog . tile ( 1 , 2 , 3 , tilesize = 256 , indexes = 1 ) # With expression with COGReader ( \"myfile.tif\" s ) as cog : tile , mask = cog . tile ( 1 , 2 , 3 , tilesize = 256 , expression = \"B1/B2\" ) part() : Read part of a raster with COGReader ( \"myfile.tif\" ) as cog : data , mask = cog . part (( 10 , 10 , 20 , 20 )) # Limit output size (default is set to 1024) with COGReader ( \"myfile.tif\" ) as cog : data , mask = cog . part (( 10 , 10 , 20 , 20 ), max_size = 2000 ) # Read high resolution with COGReader ( \"myfile.tif\" ) as cog : data , mask = cog . part (( 10 , 10 , 20 , 20 ), max_size = None ) # With indexes with COGReader ( \"myfile.tif\" ) as cog : data , mask = cog . part (( 10 , 10 , 20 , 20 ), indexes = 1 ) # With expression with COGReader ( \"myfile.tif\" ) as cog : data , mask = cog . part (( 10 , 10 , 20 , 20 ), expression = \"B1/B2\" ) preview() : Read a preview of a raster with COGReader ( \"myfile.tif\" ) as cog : data , mask = cog . preview () # With indexes with COGReader ( \"myfile.tif\" ) as cog : data , mask = cog . preview ( indexes = 1 ) # With expression with COGReader ( \"myfile.tif\" ) as cog : data , mask = cog . preview ( expression = \"B1+2,B1*4\" ) point() : Read point value of a raster with COGReader ( \"myfile.tif\" ) as cog : print ( cog . point ( - 100 , 25 )) # With indexes with COGReader ( \"myfile.tif\" ) as cog : print ( cog . point ( - 100 , 25 , indexes = 1 )) [ 1 ] # With expression with COGReader ( \"myfile.tif\" ) as cog : print ( cog . point ( - 100 , 25 , expression = \"B1+2,B1*4\" )) [ 3 , 4 ] info() : Return simple metadata about the dataset with COGReader ( \"myfile.tif\" ) as cog : print ( cog . info ()) { \"bounds\" : [ - 119.05915661478785 , 13.102845359730287 , - 84.91821332299578 , 33.995073647795806 ], \"center\" : [ - 101.98868496889182 , 23.548959503763047 , 3 ], \"minzoom\" : 3 , \"maxzoom\" : 12 , \"band_metadata\" : [[ 1 , {}]], \"band_descriptions\" : [[ 1 , \"band1\" ]], \"dtype\" : \"int8\" , \"colorinterp\" : [ \"palette\" ], \"nodata_type\" : \"Nodata\" , \"colormap\" : { \"0\" : [ 0 , 0 , 0 , 0 ], \"1\" : [ 0 , 61 , 0 , 255 ], ... } } stats() : Return image statistics (Min/Max/Stdev) with COGReader ( \"myfile.tif\" ) as cog : print ( cog . stats ()) { \"1\" : { \"pc\" : [ 1 , 16 ], \"min\" : 1 , \"max\" : 18 , \"std\" : 4.069636227214257 , \"histogram\" : [ [ ... ], [ ... ] ] } } metadata() : Return COG info + statistics with COGReader ( \"myfile.tif\" ) as cog : print ( cog . metadata ()) { \"bounds\" : [ - 119.05915661478785 , 13.102845359730287 , - 84.91821332299578 , 33.995073647795806 ], \"center\" : [ - 101.98868496889182 , 23.548959503763047 , 3 ], \"minzoom\" : 3 , \"maxzoom\" : 12 , \"band_metadata\" : [[ 1 , {}]], \"band_descriptions\" : [[ 1 , \"band1\" ]], \"dtype\" : \"int8\" , \"colorinterp\" : [ \"palette\" ], \"nodata_type\" : \"Nodata\" , \"colormap\" : { \"0\" : [ 0 , 0 , 0 , 0 ], \"1\" : [ 0 , 61 , 0 , 255 ], ... } \"statistics\" : { 1 : { \"pc\" : [ 1 , 16 ], \"min\" : 1 , \"max\" : 18 , \"std\" : 4.069636227214257 , \"histogram\" : [ [ ... ], [ ... ] ] } } } Global Options \u00b6 COGReader accept several options which will be forwarded to the rio_tiler.reader._read function (low level function accessing the data): - nodata : Overwrite the nodata value (or set if not present) - unscale : Apply internal rescaling factors - vrt_options : Pass WarpedVRT Option (see: gdal.org/api/gdalwarp_cpp.html?highlight=vrt#_CPPv415GDALWarpOptions ) - resampling_method : Set default resampling_method Note: Those options could already be passed on each method call. with COGReader ( \"my_cog.tif\" , nodata = 0 ) as cog : tile , mask = cog . tile ( 1 , 1 , 1 ) # is equivalent to with COGReader ( \"my_cog.tif\" ) as cog : tile , mask = cog . tile ( 1 , 1 , 1 , nodata = 0 ) STACReader \u00b6 In rio-tiler v2, we added a rio_tiler.io.STACReader to allow tile/metadata fetching of assets withing a STAC item. The STACReader objects has the same properties/methods as the COGReader. from typing import Dict from rio_tiler.io import STACReader with STACReader ( \"https://1tqdbvsut9.execute-api.us-west-2.amazonaws.com/v0/collections/sentinel-s2-l2a-cogs/items/S2A_34SGA_20200318_0_L2A\" , exclude_assets = { \"thumbnail\" } ) as stac : print ( stac . bounds ) print ( stac . assets ) > [ 23.293255090449595 , 31.505183020453355 , 24.296453548295318 , 32.51147809805106 ] > [ 'overview' , 'visual' , 'B01' , 'B02' , 'B03' , 'B04' , 'B05' , 'B06' , 'B07' , 'B08' , 'B8A' , 'B09' , 'B11' , 'B12' , 'AOT' , 'WVP' , 'SCL' ] # Name of assets to read assets = [ \"B01\" , \"B02\" ] with STACReader ( \"https://1tqdbvsut9.execute-api.us-west-2.amazonaws.com/v0/collections/sentinel-s2-l2a-cogs/items/S2A_34SGA_20200318_0_L2A\" , exclude_assets = { \"thumbnail\" } ) as stac : tile , mask = stac . tile ( 145 , 103 , 8 , tilesize = 256 , assets = assets ) print ( tile . shape ) > ( 2 , 256 , 256 ) # With expression with STACReader ( \"https://1tqdbvsut9.execute-api.us-west-2.amazonaws.com/v0/collections/sentinel-s2-l2a-cogs/items/S2A_34SGA_20200318_0_L2A\" , exclude_assets = { \"thumbnail\" } ) as stac : tile , mask = stac . tile ( 145 , 103 , 8 , tilesize = 256 , expression = \"B01/B02\" ) print ( tile . shape ) > ( 1 , 256 , 256 ) Note: STACReader is based on rio_tiler.io.base.MultiBaseReader class.","title":"COG/STAC Readers"},{"location":"readers/#cogreader","text":"class COGReader : \"\"\" Cloud Optimized GeoTIFF Reader. Examples -------- with COGReader(src_path) as cog: cog.tile(...) # Set global options with COGReader(src_path, unscale=True, nodata=0) as cog: cog.tile(...) with rasterio.open(src_path) as src_dst: with WarpedVRT(src_dst, ...) as vrt_dst: with COGReader(None, dataset=vrt_dst) as cog: cog.tile(...) with rasterio.open(src_path) as src_dst: with COGReader(None, dataset=src_dst) as cog: cog.tile(...) Attributes ---------- filepath: str Cloud Optimized GeoTIFF path. dataset: rasterio.DatasetReader, optional Rasterio dataset. Properties ---------- minzoom: int COG minimum zoom level. maxzoom: int COG maximum zoom level. bounds: tuple[float] COG bounds in WGS84 crs. center: tuple[float, float, int] COG center + minzoom colormap: dict COG internal colormap. Methods ------- tile(0, 0, 0, indexes=(1,2,3), expression=\"\u001dB1/B2\", tilesize=512, resampling_methods=\"nearest\") Read a map tile from the COG. part((0,10,0,10), indexes=(1,2,3,), expression=\"\u001dB1/B20\", max_size=1024) Read part of the COG. preview(max_size=1024) Read preview of the COG. point((10, 10), indexes=1) Read a point value from the COG. info: dict General information about the COG (datatype, indexes, ...) stats(pmin=5, pmax=95) Get Raster statistics. meta(pmin=5, pmax=95) Get info + raster statistics \"\"\"","title":"COGReader"},{"location":"readers/#properties","text":"dataset : Return the rasterio dataset colormap : Return the dataset's internal colormap minzoom : Return minimum Mercator Zoom maxzoom : Return maximum Mercator Zoom bounds : Return the dataset bounds in WGS84 center : Return the center of the dataset + minzoom spatial_info : Return the bounds, center and zoom infos","title":"Properties"},{"location":"readers/#methods","text":"tile() : Read map tile from a raster with COGReader ( \"myfile.tif\" ) as cog : tile , mask = cog . tile ( 1 , 2 , 3 , tilesize = 256 ) # With indexes with COGReader ( \"myfile.tif\" ) as cog : tile , mask = cog . tile ( 1 , 2 , 3 , tilesize = 256 , indexes = 1 ) # With expression with COGReader ( \"myfile.tif\" s ) as cog : tile , mask = cog . tile ( 1 , 2 , 3 , tilesize = 256 , expression = \"B1/B2\" ) part() : Read part of a raster with COGReader ( \"myfile.tif\" ) as cog : data , mask = cog . part (( 10 , 10 , 20 , 20 )) # Limit output size (default is set to 1024) with COGReader ( \"myfile.tif\" ) as cog : data , mask = cog . part (( 10 , 10 , 20 , 20 ), max_size = 2000 ) # Read high resolution with COGReader ( \"myfile.tif\" ) as cog : data , mask = cog . part (( 10 , 10 , 20 , 20 ), max_size = None ) # With indexes with COGReader ( \"myfile.tif\" ) as cog : data , mask = cog . part (( 10 , 10 , 20 , 20 ), indexes = 1 ) # With expression with COGReader ( \"myfile.tif\" ) as cog : data , mask = cog . part (( 10 , 10 , 20 , 20 ), expression = \"B1/B2\" ) preview() : Read a preview of a raster with COGReader ( \"myfile.tif\" ) as cog : data , mask = cog . preview () # With indexes with COGReader ( \"myfile.tif\" ) as cog : data , mask = cog . preview ( indexes = 1 ) # With expression with COGReader ( \"myfile.tif\" ) as cog : data , mask = cog . preview ( expression = \"B1+2,B1*4\" ) point() : Read point value of a raster with COGReader ( \"myfile.tif\" ) as cog : print ( cog . point ( - 100 , 25 )) # With indexes with COGReader ( \"myfile.tif\" ) as cog : print ( cog . point ( - 100 , 25 , indexes = 1 )) [ 1 ] # With expression with COGReader ( \"myfile.tif\" ) as cog : print ( cog . point ( - 100 , 25 , expression = \"B1+2,B1*4\" )) [ 3 , 4 ] info() : Return simple metadata about the dataset with COGReader ( \"myfile.tif\" ) as cog : print ( cog . info ()) { \"bounds\" : [ - 119.05915661478785 , 13.102845359730287 , - 84.91821332299578 , 33.995073647795806 ], \"center\" : [ - 101.98868496889182 , 23.548959503763047 , 3 ], \"minzoom\" : 3 , \"maxzoom\" : 12 , \"band_metadata\" : [[ 1 , {}]], \"band_descriptions\" : [[ 1 , \"band1\" ]], \"dtype\" : \"int8\" , \"colorinterp\" : [ \"palette\" ], \"nodata_type\" : \"Nodata\" , \"colormap\" : { \"0\" : [ 0 , 0 , 0 , 0 ], \"1\" : [ 0 , 61 , 0 , 255 ], ... } } stats() : Return image statistics (Min/Max/Stdev) with COGReader ( \"myfile.tif\" ) as cog : print ( cog . stats ()) { \"1\" : { \"pc\" : [ 1 , 16 ], \"min\" : 1 , \"max\" : 18 , \"std\" : 4.069636227214257 , \"histogram\" : [ [ ... ], [ ... ] ] } } metadata() : Return COG info + statistics with COGReader ( \"myfile.tif\" ) as cog : print ( cog . metadata ()) { \"bounds\" : [ - 119.05915661478785 , 13.102845359730287 , - 84.91821332299578 , 33.995073647795806 ], \"center\" : [ - 101.98868496889182 , 23.548959503763047 , 3 ], \"minzoom\" : 3 , \"maxzoom\" : 12 , \"band_metadata\" : [[ 1 , {}]], \"band_descriptions\" : [[ 1 , \"band1\" ]], \"dtype\" : \"int8\" , \"colorinterp\" : [ \"palette\" ], \"nodata_type\" : \"Nodata\" , \"colormap\" : { \"0\" : [ 0 , 0 , 0 , 0 ], \"1\" : [ 0 , 61 , 0 , 255 ], ... } \"statistics\" : { 1 : { \"pc\" : [ 1 , 16 ], \"min\" : 1 , \"max\" : 18 , \"std\" : 4.069636227214257 , \"histogram\" : [ [ ... ], [ ... ] ] } } }","title":"Methods"},{"location":"readers/#global-options","text":"COGReader accept several options which will be forwarded to the rio_tiler.reader._read function (low level function accessing the data): - nodata : Overwrite the nodata value (or set if not present) - unscale : Apply internal rescaling factors - vrt_options : Pass WarpedVRT Option (see: gdal.org/api/gdalwarp_cpp.html?highlight=vrt#_CPPv415GDALWarpOptions ) - resampling_method : Set default resampling_method Note: Those options could already be passed on each method call. with COGReader ( \"my_cog.tif\" , nodata = 0 ) as cog : tile , mask = cog . tile ( 1 , 1 , 1 ) # is equivalent to with COGReader ( \"my_cog.tif\" ) as cog : tile , mask = cog . tile ( 1 , 1 , 1 , nodata = 0 )","title":"Global Options"},{"location":"readers/#stacreader","text":"In rio-tiler v2, we added a rio_tiler.io.STACReader to allow tile/metadata fetching of assets withing a STAC item. The STACReader objects has the same properties/methods as the COGReader. from typing import Dict from rio_tiler.io import STACReader with STACReader ( \"https://1tqdbvsut9.execute-api.us-west-2.amazonaws.com/v0/collections/sentinel-s2-l2a-cogs/items/S2A_34SGA_20200318_0_L2A\" , exclude_assets = { \"thumbnail\" } ) as stac : print ( stac . bounds ) print ( stac . assets ) > [ 23.293255090449595 , 31.505183020453355 , 24.296453548295318 , 32.51147809805106 ] > [ 'overview' , 'visual' , 'B01' , 'B02' , 'B03' , 'B04' , 'B05' , 'B06' , 'B07' , 'B08' , 'B8A' , 'B09' , 'B11' , 'B12' , 'AOT' , 'WVP' , 'SCL' ] # Name of assets to read assets = [ \"B01\" , \"B02\" ] with STACReader ( \"https://1tqdbvsut9.execute-api.us-west-2.amazonaws.com/v0/collections/sentinel-s2-l2a-cogs/items/S2A_34SGA_20200318_0_L2A\" , exclude_assets = { \"thumbnail\" } ) as stac : tile , mask = stac . tile ( 145 , 103 , 8 , tilesize = 256 , assets = assets ) print ( tile . shape ) > ( 2 , 256 , 256 ) # With expression with STACReader ( \"https://1tqdbvsut9.execute-api.us-west-2.amazonaws.com/v0/collections/sentinel-s2-l2a-cogs/items/S2A_34SGA_20200318_0_L2A\" , exclude_assets = { \"thumbnail\" } ) as stac : tile , mask = stac . tile ( 145 , 103 , 8 , tilesize = 256 , expression = \"B01/B02\" ) print ( tile . shape ) > ( 1 , 256 , 256 ) Note: STACReader is based on rio_tiler.io.base.MultiBaseReader class.","title":"STACReader"},{"location":"release-notes/","text":"2.0b11 (2020-09-24) \u00b6 reduce verbosity in rio_tiler.tasks.filter_tasks exception logging (#266). 2.0b10 (2020-09-15) \u00b6 add post_process callback to rio_tiler.render._read and rio_tiler.render.point to apply specific operation ouput arrays. 2.0b9 (2020-09-09) \u00b6 restore Mkdocs search bar (#255) Allow class (not just instance) to be passed to pixel_selection (#250) Add Binder link/badge to README (#254) Add mkdocs-jupyter to show notebooks in website (#253) Remove deprecated functions (#247) Export modules from top-level package (#246) Allow overwriting colormap with force=True (#249) Pin black version (#251) Add contributing.md (#242) Add mkdocs config (#240) Add NPY support in rio_tiler.utils.render to save tile in numpy binary format (#256) Remove bare Exception and add more detailed errors (#248) 2.0b8 (2020-08-24) \u00b6 raise specific PointOutsideBounds in rio_tiler.reader.point (#236) 2.0b7 (2020-08-21) \u00b6 allow setting default kwargs in COGReader init (#227) allow vrt_options in COGReader.point add rio_tiler.io.base.MultiBaseReader class (#225) refactor rio_tiler.io.stac.STACReader to use MultiBaseReader (#225) add rio_tiler.task submodule to share tools for handling rio-tiler's future tasks. fix regex parsing for rio-tiler expression add warnings when assets/indexes is passed with expression option (#233) Breaking Changes: - replace dataclass wiht attr to support more flexible class definition (see #225) 2.0b6 (2020-08-04) \u00b6 add utils.create_cutline helper (#218) remove any mutable default argument depreciation - warp_vrt_option is replaced by vrt_options in rio_tiler.reader.part (#221) 2.0b5 (2020-07-31) \u00b6 add more verbosity to mosaic error (#214) Breaking Changes: - rio_tiler.mosaic.reader.mosaic_reader return ((tile, mask), assets_used) - COGReader.info is now a method instead of a property to align with other reader (#211) 2.0b4 (2020-07-30) \u00b6 add rio_tiler.io.base.BaseReader abstract class for COGReader and STACReader to inherit from STACReader raises InvalidAssetName for invalid asset name or MissingAssets when no assets is passed (#208) update rio_tiler.mosaic.reader.mosaic_reader to not use threadPool if threads <= 1 (#207) Breaking Changes: - Reader.spatial_info is a property (#203) - assets is a keyword argument in STACReader stats/info/metadata 2.0b3 (2020-07-27) \u00b6 add rio_tiler.mosaic submodule (ref: cogeotiff/rio-tiler-mosaic#16 ) 2.0b2 (2020-07-23) \u00b6 add boto3 in the dependency (#201) 2.0b1 (2020-07-22) \u00b6 switch to ContextManager for COG and STAC (rio_cogeo.io.COGReader, rio_cogeo.io.STACReader). COGReader.part and STACReader.part return data in BBOX CRS by default. STACReader now accept URL (https, s3). add more method for STAC (prewiew/point/part/info/stats). add expression for COG/STAC preview/point/part. add masked option in rio_tiler.reader.point to control weither or not it should return None or a value. remove mission specific tilers (#195). remove rio_tiler.reader.multi_* functions (replaced by rio_tiler.io.cogeo.multi_*). remove rio_tiler.utils.expression (replaced by expression options in tilers). 2.0a11 (2020-05-29) \u00b6 refactor rio_tiler.utils.tile_exists to allow raster bounds latitude == -90,90 2.0a10 (2020-05-29) \u00b6 Change default resampling to nearest for _read (#187) add rio_tiler.reader.stats (return only array statistics) remove default dst_crs in rio_tiler.reader.part to to fallback to dataset CRS. 2.0a9 (2020-05-27) \u00b6 Refactor colormap and add method to register custom colormap 2.0a8 (2020-05-25) \u00b6 add preview method to rio_tiler.io.cogeo 2.0a7 (2020-05-17) \u00b6 allow reading high resolution part of a raster (by making height, width args optional) add max_size option in rio_tiler.reader.part to set a maximum output size when height and width are not set add point and area function in rio_tiler.io.cogeo fix width-height height-widht bug in rio_tiler.reader.part depreciation - deprecated out_window option in favor of window in rio_tiler.reader._read 2.0a6 (2020-05-06) \u00b6 fix unwanted breacking change with img_profiles.get not allowing default values 2.0a5 (2020-05-06) \u00b6 make rio_tiler.io.landsat8.tile return Uint16 data and not float32 (#173) rio_tiler.profiles.img_profiles item access return copy of the items (#177) better colormap docs (#176, author @kylebarron) 2.0a4 (2020-04-08) \u00b6 add rio_tiler.io.cogeo.info to retrieve simple file metadata (no image statistics) add band metadata tag info in rio_tiler.render.metadata output add rio_tiler.io.stac STAC compliant rio_tiler.colormap.apply_discrete_cmap 2.0a3 (2020-03-25) \u00b6 only use transform_bounds when needed in rio_tiler.reader.part Breaking Changes: - switch back to gdal/rasterio calculate_default_transform (#164). Thanks to Terracotta core developper @dionhaefner. - refactor rio_tiler.utils.get_vrt_transform to get width and height input. 2.0a2 (2020-03-20) \u00b6 Fall back to gdal/rasterio calculate_default_transform for dateline separation crossing dataset (ref #164) 2.0a1 (2020-03-19) \u00b6 added reader.preview , reader.point methods added multi_* functions to rio_tiler.reader to support multiple assets addresses added rio_tiler.utils.has_mask_band function added rio_tiler.utils.get_overview_level to calculate the overview level needed for partial reading. added type hints added scale, offsets, colormap, datatype and colorinterp in reader.metadata output (#158) new rio_tiler.colormap submodule added unscale options to rio_tiler.reader._read function apply internal scale/offset (#157) Breaking Changes: - removed python 2 support - new package architecture (.io submodule) - introduced new rio_tiler.reader functions (part, preview, metadata...) - renamed rio_tiler.main to rio_tiler.io.cogeo - bucket and prefixes are defined in rio_tiler.io.dataset. {dataset}_parse function from AWS supported Public Dataset - renamed minimum_tile_cover to minimum_overlap - renamed tile_edge_padding to padding - padding is set to 0 by default. - use terracotta calculate_default_transform (see github.com/cogeotiff/rio-tiler/issues/56#issuecomment-442484999 ) - colormaps are now have an alpha value - rio_tiler.utils.get_colormap replaced by rio_tiler.colormap.get_colormap - new rio_tiler.colormap.get_colormap supports only GDAL like colormap - replaced rio_tiler.utils.array_to_image by rio_tiler.utils.render - replaced rio_tiler.utils.apply_cmap by rio_tiler.colormap.apply_cmap - replaced rio_tiler.utils._apply_discrete_colormap by rio_tiler.colormap.apply_discrete_cmap - removed histogram_bins and histogram_range in options in metadata reader. Should now be passed in hist_options (e.g: hist_options={bins=10, range=(0, 10)}) - remove alpha band value from output data array in tile/preview/metadata #127 1.4.0 (2020-02-19) \u00b6 Add Sentinel2-L2A support (#137) Update Sentinel-2 sceneid schema (S2A_tile_20170323_07SNC_0 -> S2A_L1C_20170323_07SNC_0) 1.3.1 (2019-11-06) \u00b6 Add warp_vrt_option option for utils.raster_get_stats and utils.tile_read to allow more custom VRT Warping. (ref: github.com/OSGeo/gdal/issues/1989#issue-518526399 ) Add rio_tiler.utils.non_alpha_indexes to find non-alpha band indexes (ref #127) 1.3.0 (2019-10-07) \u00b6 Allow DatasetReader , DatasetWriter , WarpedVRT input for utils.raster_get_stats and utils.tile_read add minimum_tile_cover option to filter dataset not covering a certain amount of the tile. add Sentinel-1 submodule Breaking Changes: - need rasterio>=1.1 1.2.11 (2019-09-18) \u00b6 reduce memory footprint of expression tiler fix wrong calculation for overview size in raster_get_stats (#116) Add Landsat 8 QA Band (#117). 1.2.10 (2019-07-18) \u00b6 add more colormap options (from matplotlib) and switch from txt files to numpy binaries (#115) 1.2.9 (2019-07-11) \u00b6 fix issue #113, adds depreciation warning for bounds_crs in favor of dst_crs in rio_tiler.utils.get_vrt_transform 1.2.8 (2019-07-08) \u00b6 Add kwargs options in landsat8.tile, sentinel2.tile and cbers.tile functions to allow resampling_method and tile_edge_padding options forwarding to utils._tile_read. Add Input (bounds_crs) and Output (dst_crs) option to utils._tile_read function (#108) 1.2.7 (2019-05-14) \u00b6 Revert changes introduced in #106 (see #105) Refactor tests 1.2.6 (2019-05-10) - DELETED \u00b6 Use same resampling method for mask and for data (#105) 1.2.5 (2019-05-08) \u00b6 add tile_edge_padding option to be passed to rio_tiler.utils._tile_read to reduce sharp edges that occur due to resampling (#104) 1.2.4 (2019-04-16) \u00b6 add histogram_range options to be passed to rio_tiler.{module}.metadata function (#102) 1.2.3 (2019-04-04) \u00b6 add histogram_bins options to be passed to rio_tiler.{module}.metadata function (#98) Bug fixes: - return index number with band descriptions (#99) 1.2.2 (2019-04-03) \u00b6 add mercator min/max zoom info in metadata output from rio_tiler.utils.raster_get_stats (#96) add band description (band name) in metadata output from rio_tiler.utils.raster_get_stats (#96) 1.2.1 (2019-03-26) \u00b6 Replace rio-pansharpen dependency with a fork of the brovey function directly into rio_tiler.utils (rio-pansharpen is unmaintened and not compatible with rasterio>=1) (#94). 1.2.0 (2019-03-26) \u00b6 rio_tiler.utils.array_to_image 's color_map arg can be a dictionary of discrete values (#91) Breaking Changes: - expr argument is now a required option in rio_tiler.utils.expression . (#88) 1.1.4 (2019-03-11) \u00b6 Add 'rplumbo' colormap (#90 by @DanSchoppe) 1.1.3 (2019-03-06) \u00b6 Bug fixes: - Fix casting to integer for MAX_THREADS environment variable. 1.1.1 (2019-02-21) \u00b6 Minor typo correction and harmonization of the use of src/src_dst/src_path in rio_tiler.utils Bug fixes: - Fix nodata handling in utils.raster_get_stats 1.1.0 (2019-02-15) \u00b6 Allow options forwarding to tile_read from main.tile function (#86) Add resampling_method options in rio_tiler.utils.tile_read to allow user set resampling. Default is now bilinear (#85) Bug fixes: - Fix nodata option forwarding to tile_read when source is a path (#83) Refactoring: - Refactor rio_tiler.utils.tile_read to reduce code complexity (#84) Breaking Changes: - indexes options is now set to None in rio_tiler.utils.tile_read . Default will now be the dataset indexes. 1.0.1 (2019-02-14) \u00b6 Fix mask datatype bug in rio_tiler.utils.array_to_image (#79) Fix nodata handling and better test for the nodata/mask main module (#81) 1.0.0 (2019-02-11) \u00b6 add missing Landsat panchromatic band (08) min/max fetch in rio_tiler.landsat8.metadata (#58) add pre-commit for commit validation (#64) code formatting using Black (the uncompromising Python code formatter) (#64) update documentation (Sentinel-2 cost) (#68) add utils.raster_get_stats and utils._get_stats to replace min_max* function and to return more statistics (#66) add overview level selection to statistical functions to reduce the data download (#59) add pure GDAL array_to_image function to replace PIL tools (#29) add GDAL format output from utils.get_colormap to be used in array_to_image (#29) add GDAL compatible Image creation profile (#29) add max threads number settings via \"MAX_THREADS\" environment variable (#71) Breaking Changes: - update metadata structure returned by landsat8.metadata , sentinel2.metadata , cbers.metadata - force sentinel, landsat and cbers band names to be string and add validation (#65) - moved landsat utility functions from rio_tiler.utils to rio_tiler.landsat8 - rio_tiler.utils.landsat_get_mtl -> rio_tiler.landsat8._landsat_get_mtl - rio_tiler.utils.landsat_parse_scene_id -> rio_tiler.landsat8._landsat_parse_scene_id - rio_tiler.utils.landsat_get_stats -> rio_tiler.landsat8._landsat_stats - moved cbers utility functions from rio_tiler.utils to rio_tiler.cbers - rio_tiler.utils.cbers_parse_scene_id -> rio_tiler.cbers._cbers_parse_scene_id - moved sentinel-2 utility functions from rio_tiler.utils to rio_tiler.sentinel2 - rio_tiler.utils.sentinel_parse_scene_id -> rio_tiler.sentinel2._sentinel_parse_scene_id - removed deprecated PIL support as well as base64 encoding function in rio_tiler.utils - rio_tiler.utils.img_to_buffer - rio_tiler.utils.array_to_img - rio_tiler.utils.b64_encode_img - removed deprecated min_max* functions (landsat_min_max_worker and band_min_max_worker) 1.0rc2 (2018-08-22) \u00b6 add test case for pix4d nodata+alpha band data 1.0rc1 (2018-07-16) \u00b6 rasterio 1.0.0 1.0b3 (2018-07-02) \u00b6 add schwarzwald color palette 1.0b2 (2018-06-26) \u00b6 fix nodata (#48) 1.0b1 (2018-06-23) \u00b6 adapt to rasterio 1.0b4 fix mask (internal/external) fetching \ud83d\ude4f fix boundless read with new rasterio 1.0b2 fix custom nodata handling fix performances issue Breaking Changes: - removed alpha band options to select a custom alpha band number 1.0a8 (2018-06-20) \u00b6 Fix rasterio version to 1.0b1 (#46 and #44) 1.0a7 (2018-05-14) \u00b6 Support for additional CBERS instruments (fredliporace) 1.0a6 (2018-03-29) \u00b6 Fixes sentinel-2 band 8A regex bug in rio_tiler.utils.expression 1.0a5 (2018-03-26) \u00b6 adds DatasetReader input option for utils.tile_read (do not close the dataset on each read) Breaking Changes: - utils.tile_band_worker renamed to utils.tile_read - main.tile rgb option renamed indexes - sentinel2.tile , landsat8.tile , cbers.tile rgb option renamed bands - main.tile default nodata mask is handled by rasterio 1.0a4 (2018-03-07) \u00b6 adds utils.b64_encode_img function to encode an image object into a base64 string add tiles profiles (jpeg, png, webp) based on github.com/mapnik/mapnik/wiki/Image-IO#default-output-details Breaking Changes: - Refactor rio_tiler.utils.array_to_img to return PIL image object 1.0a3 (2018-02-05) \u00b6 only using read_masks for mask creation when it's needed. 1.0a2 (2018-02-05) \u00b6 add \"expression\" utility function better nodata/mask/alpha band definition and support Breaking Changes: - tile functions now return an associated mask (Landsat, Sentinel, CBERS, main) - remove nodata support in utils.image_to_array function - add mask support in utils.image_to_array function - utils.tile_band_worker will always return a (Band, Width, Height) array (e.g 1x256x256 or 3x256x256) 1.0a1 (2018-01-04) \u00b6 remove aws.py sub-module (replaced by main.py) no default bands value for main.py tiles. 1.0a.0 (2018-01-03) \u00b6 add colormap option in utils.array_to_img add TIR (brightness temps) support add CBERS support add global file support add elevation encoding for mapzen removing internal caching update to rasterio 1.0a12 Breaking Changes: - remove data value rescaling in landsat8.tile and sentinel2.tile - fix wrong lat/grid_square value in utils.sentinel_parse_scene_id - rename utils.sentinel_min_max_worker to utils.band_min_max_worker 0.0.3 (2017-11-14) \u00b6 Fix Sentinel-2 bad AWS url 0.0.2 (2017-10-17) \u00b6 Fix python \u2154 compatibilities in rio_tiler.utils.landsat_get_mtl 0.0.1 (2017-10-05) \u00b6 Initial release. Requires Rasterio >= 1.0a10.","title":"Release Notes"},{"location":"release-notes/#20b11-2020-09-24","text":"reduce verbosity in rio_tiler.tasks.filter_tasks exception logging (#266).","title":"2.0b11 (2020-09-24)"},{"location":"release-notes/#20b10-2020-09-15","text":"add post_process callback to rio_tiler.render._read and rio_tiler.render.point to apply specific operation ouput arrays.","title":"2.0b10 (2020-09-15)"},{"location":"release-notes/#20b9-2020-09-09","text":"restore Mkdocs search bar (#255) Allow class (not just instance) to be passed to pixel_selection (#250) Add Binder link/badge to README (#254) Add mkdocs-jupyter to show notebooks in website (#253) Remove deprecated functions (#247) Export modules from top-level package (#246) Allow overwriting colormap with force=True (#249) Pin black version (#251) Add contributing.md (#242) Add mkdocs config (#240) Add NPY support in rio_tiler.utils.render to save tile in numpy binary format (#256) Remove bare Exception and add more detailed errors (#248)","title":"2.0b9 (2020-09-09)"},{"location":"release-notes/#20b8-2020-08-24","text":"raise specific PointOutsideBounds in rio_tiler.reader.point (#236)","title":"2.0b8 (2020-08-24)"},{"location":"release-notes/#20b7-2020-08-21","text":"allow setting default kwargs in COGReader init (#227) allow vrt_options in COGReader.point add rio_tiler.io.base.MultiBaseReader class (#225) refactor rio_tiler.io.stac.STACReader to use MultiBaseReader (#225) add rio_tiler.task submodule to share tools for handling rio-tiler's future tasks. fix regex parsing for rio-tiler expression add warnings when assets/indexes is passed with expression option (#233) Breaking Changes: - replace dataclass wiht attr to support more flexible class definition (see #225)","title":"2.0b7 (2020-08-21)"},{"location":"release-notes/#20b6-2020-08-04","text":"add utils.create_cutline helper (#218) remove any mutable default argument depreciation - warp_vrt_option is replaced by vrt_options in rio_tiler.reader.part (#221)","title":"2.0b6 (2020-08-04)"},{"location":"release-notes/#20b5-2020-07-31","text":"add more verbosity to mosaic error (#214) Breaking Changes: - rio_tiler.mosaic.reader.mosaic_reader return ((tile, mask), assets_used) - COGReader.info is now a method instead of a property to align with other reader (#211)","title":"2.0b5 (2020-07-31)"},{"location":"release-notes/#20b4-2020-07-30","text":"add rio_tiler.io.base.BaseReader abstract class for COGReader and STACReader to inherit from STACReader raises InvalidAssetName for invalid asset name or MissingAssets when no assets is passed (#208) update rio_tiler.mosaic.reader.mosaic_reader to not use threadPool if threads <= 1 (#207) Breaking Changes: - Reader.spatial_info is a property (#203) - assets is a keyword argument in STACReader stats/info/metadata","title":"2.0b4 (2020-07-30)"},{"location":"release-notes/#20b3-2020-07-27","text":"add rio_tiler.mosaic submodule (ref: cogeotiff/rio-tiler-mosaic#16 )","title":"2.0b3 (2020-07-27)"},{"location":"release-notes/#20b2-2020-07-23","text":"add boto3 in the dependency (#201)","title":"2.0b2 (2020-07-23)"},{"location":"release-notes/#20b1-2020-07-22","text":"switch to ContextManager for COG and STAC (rio_cogeo.io.COGReader, rio_cogeo.io.STACReader). COGReader.part and STACReader.part return data in BBOX CRS by default. STACReader now accept URL (https, s3). add more method for STAC (prewiew/point/part/info/stats). add expression for COG/STAC preview/point/part. add masked option in rio_tiler.reader.point to control weither or not it should return None or a value. remove mission specific tilers (#195). remove rio_tiler.reader.multi_* functions (replaced by rio_tiler.io.cogeo.multi_*). remove rio_tiler.utils.expression (replaced by expression options in tilers).","title":"2.0b1 (2020-07-22)"},{"location":"release-notes/#20a11-2020-05-29","text":"refactor rio_tiler.utils.tile_exists to allow raster bounds latitude == -90,90","title":"2.0a11 (2020-05-29)"},{"location":"release-notes/#20a10-2020-05-29","text":"Change default resampling to nearest for _read (#187) add rio_tiler.reader.stats (return only array statistics) remove default dst_crs in rio_tiler.reader.part to to fallback to dataset CRS.","title":"2.0a10 (2020-05-29)"},{"location":"release-notes/#20a9-2020-05-27","text":"Refactor colormap and add method to register custom colormap","title":"2.0a9 (2020-05-27)"},{"location":"release-notes/#20a8-2020-05-25","text":"add preview method to rio_tiler.io.cogeo","title":"2.0a8 (2020-05-25)"},{"location":"release-notes/#20a7-2020-05-17","text":"allow reading high resolution part of a raster (by making height, width args optional) add max_size option in rio_tiler.reader.part to set a maximum output size when height and width are not set add point and area function in rio_tiler.io.cogeo fix width-height height-widht bug in rio_tiler.reader.part depreciation - deprecated out_window option in favor of window in rio_tiler.reader._read","title":"2.0a7 (2020-05-17)"},{"location":"release-notes/#20a6-2020-05-06","text":"fix unwanted breacking change with img_profiles.get not allowing default values","title":"2.0a6 (2020-05-06)"},{"location":"release-notes/#20a5-2020-05-06","text":"make rio_tiler.io.landsat8.tile return Uint16 data and not float32 (#173) rio_tiler.profiles.img_profiles item access return copy of the items (#177) better colormap docs (#176, author @kylebarron)","title":"2.0a5 (2020-05-06)"},{"location":"release-notes/#20a4-2020-04-08","text":"add rio_tiler.io.cogeo.info to retrieve simple file metadata (no image statistics) add band metadata tag info in rio_tiler.render.metadata output add rio_tiler.io.stac STAC compliant rio_tiler.colormap.apply_discrete_cmap","title":"2.0a4 (2020-04-08)"},{"location":"release-notes/#20a3-2020-03-25","text":"only use transform_bounds when needed in rio_tiler.reader.part Breaking Changes: - switch back to gdal/rasterio calculate_default_transform (#164). Thanks to Terracotta core developper @dionhaefner. - refactor rio_tiler.utils.get_vrt_transform to get width and height input.","title":"2.0a3 (2020-03-25)"},{"location":"release-notes/#20a2-2020-03-20","text":"Fall back to gdal/rasterio calculate_default_transform for dateline separation crossing dataset (ref #164)","title":"2.0a2 (2020-03-20)"},{"location":"release-notes/#20a1-2020-03-19","text":"added reader.preview , reader.point methods added multi_* functions to rio_tiler.reader to support multiple assets addresses added rio_tiler.utils.has_mask_band function added rio_tiler.utils.get_overview_level to calculate the overview level needed for partial reading. added type hints added scale, offsets, colormap, datatype and colorinterp in reader.metadata output (#158) new rio_tiler.colormap submodule added unscale options to rio_tiler.reader._read function apply internal scale/offset (#157) Breaking Changes: - removed python 2 support - new package architecture (.io submodule) - introduced new rio_tiler.reader functions (part, preview, metadata...) - renamed rio_tiler.main to rio_tiler.io.cogeo - bucket and prefixes are defined in rio_tiler.io.dataset. {dataset}_parse function from AWS supported Public Dataset - renamed minimum_tile_cover to minimum_overlap - renamed tile_edge_padding to padding - padding is set to 0 by default. - use terracotta calculate_default_transform (see github.com/cogeotiff/rio-tiler/issues/56#issuecomment-442484999 ) - colormaps are now have an alpha value - rio_tiler.utils.get_colormap replaced by rio_tiler.colormap.get_colormap - new rio_tiler.colormap.get_colormap supports only GDAL like colormap - replaced rio_tiler.utils.array_to_image by rio_tiler.utils.render - replaced rio_tiler.utils.apply_cmap by rio_tiler.colormap.apply_cmap - replaced rio_tiler.utils._apply_discrete_colormap by rio_tiler.colormap.apply_discrete_cmap - removed histogram_bins and histogram_range in options in metadata reader. Should now be passed in hist_options (e.g: hist_options={bins=10, range=(0, 10)}) - remove alpha band value from output data array in tile/preview/metadata #127","title":"2.0a1 (2020-03-19)"},{"location":"release-notes/#140-2020-02-19","text":"Add Sentinel2-L2A support (#137) Update Sentinel-2 sceneid schema (S2A_tile_20170323_07SNC_0 -> S2A_L1C_20170323_07SNC_0)","title":"1.4.0 (2020-02-19)"},{"location":"release-notes/#131-2019-11-06","text":"Add warp_vrt_option option for utils.raster_get_stats and utils.tile_read to allow more custom VRT Warping. (ref: github.com/OSGeo/gdal/issues/1989#issue-518526399 ) Add rio_tiler.utils.non_alpha_indexes to find non-alpha band indexes (ref #127)","title":"1.3.1 (2019-11-06)"},{"location":"release-notes/#130-2019-10-07","text":"Allow DatasetReader , DatasetWriter , WarpedVRT input for utils.raster_get_stats and utils.tile_read add minimum_tile_cover option to filter dataset not covering a certain amount of the tile. add Sentinel-1 submodule Breaking Changes: - need rasterio>=1.1","title":"1.3.0 (2019-10-07)"},{"location":"release-notes/#1211-2019-09-18","text":"reduce memory footprint of expression tiler fix wrong calculation for overview size in raster_get_stats (#116) Add Landsat 8 QA Band (#117).","title":"1.2.11 (2019-09-18)"},{"location":"release-notes/#1210-2019-07-18","text":"add more colormap options (from matplotlib) and switch from txt files to numpy binaries (#115)","title":"1.2.10 (2019-07-18)"},{"location":"release-notes/#129-2019-07-11","text":"fix issue #113, adds depreciation warning for bounds_crs in favor of dst_crs in rio_tiler.utils.get_vrt_transform","title":"1.2.9 (2019-07-11)"},{"location":"release-notes/#128-2019-07-08","text":"Add kwargs options in landsat8.tile, sentinel2.tile and cbers.tile functions to allow resampling_method and tile_edge_padding options forwarding to utils._tile_read. Add Input (bounds_crs) and Output (dst_crs) option to utils._tile_read function (#108)","title":"1.2.8 (2019-07-08)"},{"location":"release-notes/#127-2019-05-14","text":"Revert changes introduced in #106 (see #105) Refactor tests","title":"1.2.7 (2019-05-14)"},{"location":"release-notes/#126-2019-05-10-deleted","text":"Use same resampling method for mask and for data (#105)","title":"1.2.6 (2019-05-10) - DELETED"},{"location":"release-notes/#125-2019-05-08","text":"add tile_edge_padding option to be passed to rio_tiler.utils._tile_read to reduce sharp edges that occur due to resampling (#104)","title":"1.2.5 (2019-05-08)"},{"location":"release-notes/#124-2019-04-16","text":"add histogram_range options to be passed to rio_tiler.{module}.metadata function (#102)","title":"1.2.4 (2019-04-16)"},{"location":"release-notes/#123-2019-04-04","text":"add histogram_bins options to be passed to rio_tiler.{module}.metadata function (#98) Bug fixes: - return index number with band descriptions (#99)","title":"1.2.3 (2019-04-04)"},{"location":"release-notes/#122-2019-04-03","text":"add mercator min/max zoom info in metadata output from rio_tiler.utils.raster_get_stats (#96) add band description (band name) in metadata output from rio_tiler.utils.raster_get_stats (#96)","title":"1.2.2 (2019-04-03)"},{"location":"release-notes/#121-2019-03-26","text":"Replace rio-pansharpen dependency with a fork of the brovey function directly into rio_tiler.utils (rio-pansharpen is unmaintened and not compatible with rasterio>=1) (#94).","title":"1.2.1 (2019-03-26)"},{"location":"release-notes/#120-2019-03-26","text":"rio_tiler.utils.array_to_image 's color_map arg can be a dictionary of discrete values (#91) Breaking Changes: - expr argument is now a required option in rio_tiler.utils.expression . (#88)","title":"1.2.0 (2019-03-26)"},{"location":"release-notes/#114-2019-03-11","text":"Add 'rplumbo' colormap (#90 by @DanSchoppe)","title":"1.1.4 (2019-03-11)"},{"location":"release-notes/#113-2019-03-06","text":"Bug fixes: - Fix casting to integer for MAX_THREADS environment variable.","title":"1.1.3 (2019-03-06)"},{"location":"release-notes/#111-2019-02-21","text":"Minor typo correction and harmonization of the use of src/src_dst/src_path in rio_tiler.utils Bug fixes: - Fix nodata handling in utils.raster_get_stats","title":"1.1.1 (2019-02-21)"},{"location":"release-notes/#110-2019-02-15","text":"Allow options forwarding to tile_read from main.tile function (#86) Add resampling_method options in rio_tiler.utils.tile_read to allow user set resampling. Default is now bilinear (#85) Bug fixes: - Fix nodata option forwarding to tile_read when source is a path (#83) Refactoring: - Refactor rio_tiler.utils.tile_read to reduce code complexity (#84) Breaking Changes: - indexes options is now set to None in rio_tiler.utils.tile_read . Default will now be the dataset indexes.","title":"1.1.0 (2019-02-15)"},{"location":"release-notes/#101-2019-02-14","text":"Fix mask datatype bug in rio_tiler.utils.array_to_image (#79) Fix nodata handling and better test for the nodata/mask main module (#81)","title":"1.0.1 (2019-02-14)"},{"location":"release-notes/#100-2019-02-11","text":"add missing Landsat panchromatic band (08) min/max fetch in rio_tiler.landsat8.metadata (#58) add pre-commit for commit validation (#64) code formatting using Black (the uncompromising Python code formatter) (#64) update documentation (Sentinel-2 cost) (#68) add utils.raster_get_stats and utils._get_stats to replace min_max* function and to return more statistics (#66) add overview level selection to statistical functions to reduce the data download (#59) add pure GDAL array_to_image function to replace PIL tools (#29) add GDAL format output from utils.get_colormap to be used in array_to_image (#29) add GDAL compatible Image creation profile (#29) add max threads number settings via \"MAX_THREADS\" environment variable (#71) Breaking Changes: - update metadata structure returned by landsat8.metadata , sentinel2.metadata , cbers.metadata - force sentinel, landsat and cbers band names to be string and add validation (#65) - moved landsat utility functions from rio_tiler.utils to rio_tiler.landsat8 - rio_tiler.utils.landsat_get_mtl -> rio_tiler.landsat8._landsat_get_mtl - rio_tiler.utils.landsat_parse_scene_id -> rio_tiler.landsat8._landsat_parse_scene_id - rio_tiler.utils.landsat_get_stats -> rio_tiler.landsat8._landsat_stats - moved cbers utility functions from rio_tiler.utils to rio_tiler.cbers - rio_tiler.utils.cbers_parse_scene_id -> rio_tiler.cbers._cbers_parse_scene_id - moved sentinel-2 utility functions from rio_tiler.utils to rio_tiler.sentinel2 - rio_tiler.utils.sentinel_parse_scene_id -> rio_tiler.sentinel2._sentinel_parse_scene_id - removed deprecated PIL support as well as base64 encoding function in rio_tiler.utils - rio_tiler.utils.img_to_buffer - rio_tiler.utils.array_to_img - rio_tiler.utils.b64_encode_img - removed deprecated min_max* functions (landsat_min_max_worker and band_min_max_worker)","title":"1.0.0 (2019-02-11)"},{"location":"release-notes/#10rc2-2018-08-22","text":"add test case for pix4d nodata+alpha band data","title":"1.0rc2 (2018-08-22)"},{"location":"release-notes/#10rc1-2018-07-16","text":"rasterio 1.0.0","title":"1.0rc1 (2018-07-16)"},{"location":"release-notes/#10b3-2018-07-02","text":"add schwarzwald color palette","title":"1.0b3 (2018-07-02)"},{"location":"release-notes/#10b2-2018-06-26","text":"fix nodata (#48)","title":"1.0b2 (2018-06-26)"},{"location":"release-notes/#10b1-2018-06-23","text":"adapt to rasterio 1.0b4 fix mask (internal/external) fetching \ud83d\ude4f fix boundless read with new rasterio 1.0b2 fix custom nodata handling fix performances issue Breaking Changes: - removed alpha band options to select a custom alpha band number","title":"1.0b1 (2018-06-23)"},{"location":"release-notes/#10a8-2018-06-20","text":"Fix rasterio version to 1.0b1 (#46 and #44)","title":"1.0a8 (2018-06-20)"},{"location":"release-notes/#10a7-2018-05-14","text":"Support for additional CBERS instruments (fredliporace)","title":"1.0a7 (2018-05-14)"},{"location":"release-notes/#10a6-2018-03-29","text":"Fixes sentinel-2 band 8A regex bug in rio_tiler.utils.expression","title":"1.0a6 (2018-03-29)"},{"location":"release-notes/#10a5-2018-03-26","text":"adds DatasetReader input option for utils.tile_read (do not close the dataset on each read) Breaking Changes: - utils.tile_band_worker renamed to utils.tile_read - main.tile rgb option renamed indexes - sentinel2.tile , landsat8.tile , cbers.tile rgb option renamed bands - main.tile default nodata mask is handled by rasterio","title":"1.0a5 (2018-03-26)"},{"location":"release-notes/#10a4-2018-03-07","text":"adds utils.b64_encode_img function to encode an image object into a base64 string add tiles profiles (jpeg, png, webp) based on github.com/mapnik/mapnik/wiki/Image-IO#default-output-details Breaking Changes: - Refactor rio_tiler.utils.array_to_img to return PIL image object","title":"1.0a4 (2018-03-07)"},{"location":"release-notes/#10a3-2018-02-05","text":"only using read_masks for mask creation when it's needed.","title":"1.0a3 (2018-02-05)"},{"location":"release-notes/#10a2-2018-02-05","text":"add \"expression\" utility function better nodata/mask/alpha band definition and support Breaking Changes: - tile functions now return an associated mask (Landsat, Sentinel, CBERS, main) - remove nodata support in utils.image_to_array function - add mask support in utils.image_to_array function - utils.tile_band_worker will always return a (Band, Width, Height) array (e.g 1x256x256 or 3x256x256)","title":"1.0a2 (2018-02-05)"},{"location":"release-notes/#10a1-2018-01-04","text":"remove aws.py sub-module (replaced by main.py) no default bands value for main.py tiles.","title":"1.0a1 (2018-01-04)"},{"location":"release-notes/#10a0-2018-01-03","text":"add colormap option in utils.array_to_img add TIR (brightness temps) support add CBERS support add global file support add elevation encoding for mapzen removing internal caching update to rasterio 1.0a12 Breaking Changes: - remove data value rescaling in landsat8.tile and sentinel2.tile - fix wrong lat/grid_square value in utils.sentinel_parse_scene_id - rename utils.sentinel_min_max_worker to utils.band_min_max_worker","title":"1.0a.0 (2018-01-03)"},{"location":"release-notes/#003-2017-11-14","text":"Fix Sentinel-2 bad AWS url","title":"0.0.3 (2017-11-14)"},{"location":"release-notes/#002-2017-10-17","text":"Fix python \u2154 compatibilities in rio_tiler.utils.landsat_get_mtl","title":"0.0.2 (2017-10-17)"},{"location":"release-notes/#001-2017-10-05","text":"Initial release. Requires Rasterio >= 1.0a10.","title":"0.0.1 (2017-10-05)"},{"location":"v2_migration/","text":"rio-tiler version 2.0 introduced many breaking changes . This document aims to help with migrating your code to use rio-tiler 2.0. Python 3 only \u00b6 First and foremost is the drop of Python 2 support. We are in 2020 and Python 2 is officially dead . For ease of maintenance we decided to remove Python 2 support and to continue with only Python 3. Python 3.5 or later is required. If you need help moving from Python 2 to 3 check out the official transition documentation . Type hints \u00b6 As part of switching to Python 3, we also embraced modern code style with the adoption of type hints. Python 3.6+ has new syntax support for optional \"type hinting\" -- declaring the type of a variable -- which enables an improved development experience in editors and tools. This does not require any changes to your code as long as you're using Python 3.6+. For more information see: fastapi.tiangolo.com/python-types/ kishstats.com/python/2019/01/07/python-type-hinting.html mypy.readthedocs.io/en/stable/cheat_sheet_py3.html Typing example: def get_vrt_transform ( src_dst : Union [ DatasetReader , DatasetWriter , WarpedVRT ], bounds : Tuple [ float , float , float , float ], dst_crs : CRS = constants . WEB_MERCATOR_CRS , ) -> Tuple [ Affine , int , int ]: Rasterio >= 1.1.3 \u00b6 Rasterio 1.1.3 or newer is required. Recent changes in rasterio makes masking more reliable. New rio_tiler.io submodules \u00b6 We created revised submodules for working with COGs and STAC: rio_tiler.io.cogeo is a modified version of the previous rio_tiler.main.tile . rio_tiler.io.stac is a new module to work with SpatioTemporal Asset Catalogs (STAC) . We now support reading files through a ContextManager to enable accessing the source rasterio dataset. # v1 from rio_tiler.main import tile as cogTiler tile , mask = cogTiler ( 'my_tif.tif' , 691559 , 956905 , 21 , tilesize = 256 ) # v2 from rio_tiler.io import COGReader with COGReader ( \"my_tif.tif\" ) as cog : tile , mask = cog . tile ( 691559 , 956905 , 21 , tilesize = 256 ) print ( cog . dataset ) # rasterio dataset (returned by rasterio.open()) print ( cog . dataset . meta ) # rasterio metadata print ( cog . bounds ) # WGS84 bounds print ( cog . colormap ) # internal colormap Expression support is now directly available in the COGReader with COGReader ( \"my_tif.tif\" ) as cog : tile , mask = cog . tile ( 691559 , 956905 , 21 , expression = \"b1/b2\" ) COGReader description \u00b6 class COGReader : \"\"\" Cloud Optimized GeoTIFF Reader. Examples -------- with COGReader(src_path) as cog: cog.tile(...) with rasterio.open(src_path) as src_dst: with WarpedVRT(src_dst, ...) as vrt_dst: with COGReader(None, dataset=vrt_dst) as cog: cog.tile(...) with rasterio.open(src_path) as src_dst: with COGReader(None, dataset=src_dst) as cog: cog.tile(...) Attributes ---------- filepath: str Cloud Optimized GeoTIFF path. dataset: rasterio.DatasetReader, optional Rasterio dataset. Properties ---------- minzoom: int COG minimum zoom level. maxzoom: int COG maximum zoom level. bounds: tuple[float] COG bounds in WGS84 crs. center: tuple[float, float, int] COG center + minzoom colormap: dict COG internal colormap. info: dict General information about the COG (datatype, indexes, ...) Methods ------- tile(0, 0, 0, indexes=(1,2,3), expression=\"\u001dB1/B2\", tilesize=512, resampling_methods=\"nearest\") Read a map tile from the COG. part((0,10,0,10), indexes=(1,2,3,), expression=\"\u001dB1/B20\", max_size=1024) Read part of the COG. preview(max_size=1024) Read preview of the COG. point((10, 10), indexes=1) Read a point value from the COG. stats(pmin=5, pmax=95) Get Raster statistics. meta(pmin=5, pmax=95) Get info + raster statistics \"\"\" Internal API: rio_tiler.reader \u00b6 Internal tile/data reading functions have been refactored and moved to a new rio_tiler.reader submodule. tile \u00b6 In rio_tiler==1 most of the magic was happening in rio_tiler.utils._tile_read . In rio_tiler==2 this function is now split in two, rio_tiler.reader.part and rio_tiler_reader._read , to reduce code reutilisation and to make the code more robust. The part function now takes height and width instead of a unique tilesize to specify the output array size. To ease the transition we added a rio_tiler.reader.tile function. Note: The new rio_tiler.reader.part function enables to perform non-squared data cropping by passing output width and height (instead of just tilesize). # v1 with rasterio . open ( \"my_tif.tif\" ) as src_dst : # get tile bounds and read raster mercator_tile = mercantile . Tile ( x = tile_x , y = tile_y , z = tile_z ) tile_bounds = mercantile . xy_bounds ( mercator_tile ) t , m = rio_tiler . utils . _tile_read ( src , tile_bounds , 256 ) # v2 with rasterio . open ( \"my_tif.tif\" ) as src_dst : t , m = rio_tiler . reader . tile ( src_dst , tile_x , tile_y , tile_z , 256 ) # Will check if tile is valid # Or with rasterio . open ( \"my_tif.tif\" ) as src_dst : mercator_tile = mercantile . Tile ( x = tile_x , y = tile_y , z = tile_z ) tile_bounds = mercantile . xy_bounds ( mercator_tile ) t , m = rio_tiler . reader . part ( src_dst , tile_bounds , 256 , 256 ) Options changes - tile_edge_padding -> padding , and set to 0 by default - minimum_tile_cover -> minimum_overlap - unscale ( New ): add ability to apply scale and offset to the data (Default: False) # v1 with rasterio . open ( \"my_tif.tif\" ) as src_dst : mercator_tile = mercantile . Tile ( x = tile_x , y = tile_y , z = tile_z ) tile_bounds = mercantile . xy_bounds ( mercator_tile ) t , m = rio_tiler . utils . _tile_read ( src , tile_bounds , 256 , tile_edge_padding = 4 , minimum_tile_cover = 0.3 ) # v2 with rasterio . open ( \"my_tif.tif\" ) as src_dst : t , m = rio_tiler . reader . tile ( src_dst , tile_x , tile_y , tile_z , 256 , padding = 4 , minimum_overlap = 0.3 ) Alpha band \u00b6 Since the first version, rio-tiler returns a tuple of (data, mask) in most of the reading function. This design was made early and without thinking about datasets with an alpha channel, which resulted in issues like #126 , where a user gets a 4 bands data array + a mask (instead of 3 bands + mask). In rio-tiler=2. , when no indexes options are passed, we remove the alpha channel from the output data array. # v1 with rasterio . open ( \"my_tif_alpha.tif\" ) as src_dst : t , m = rio_tiler . utils . _tile_read ( src , tile_bounds , 256 , indexes = ( 1 , 2 , 3 )) # v2 with rasterio . open ( \"my_tif_alpha.tif\" ) as src_dst : # because rio-tiler will remove the alpha band we don't need to use the indexes option t , m = rio_tiler . reader . tile ( src_dst , tile_x , tile_y , tile_z , 256 ) metadata \u00b6 rio_tiler.utils._raster_get_stats has been replaced by rio_tiler.reader.metadata which uses the new reader.part and reader.preview functions. Meaning that now you can get metadata for a specific area by passing a bbox. To limit the data transfer (with the idea of getting the metadata from the COG overviews) we use only the max_size options, meaning the overview_level options have been removed (at least for version 2.0.0). # v1 import rio_tiler with rasterio . open ( \"my_tif.tif\" ) as src_dst : meta = rio_tiler . utils . _raster_get_stats ( src_dst ) # v2 with rasterio . open ( \"my_tif.tif\" ) as src_dst : rio_tiler . reader . metadata ( src_dst ) Options changes - removed histogram_bins and histogram_range which should now be passed in hist_options (e.g: hist_options={bins=10, range=(0, 10)}) - removed overview_level - added bounds Output The output has also been updated. The new metadata output doesn't return min/max zoom and bounds is return in WGS84 by default. # v1 with rasterio . open ( \"my_tif.tif\" ) as src_dst : rio_tiler . utils . _raster_get_stats ( src_dst ) > { \"bounds\" : { \"value\" : [ - 119.05915661478785 , 13.102845359730287 , - 84.91821332299578 , 33.995073647795806 ], \"crs\" : \"EPSG:4326\" }, \"minzoom\" : 3 , \"maxzoom\" : 12 , \"band_descriptions\" : [ [ 1 , \"band1\" ] ], \"statistics\" : { \"1\" : { \"pc\" : [ 1 , 17 ], \"min\" : 1 , \"max\" : 18 , \"std\" : 4.418616203143802 , \"histogram\" : [ [ ... ], [ ... ] ] } } } # v2 with rasterio . open ( \"my_tif.tif\" ) as src_dst : rio_tiler . reader . metadata ( src_dst ) > { \"bounds\" : [ - 119.05915661478785 , 13.102845359730287 , - 84.91821332299578 , 33.995073647795806 ], \"statistics\" : { \"1\" : { \"pc\" : [ 1 , 16 ], \"min\" : 1 , \"max\" : 18 , \"std\" : 4.069636227214257 , \"histogram\" : [ [ ... ], [ ... ] ] } }, \"nodata_type\" : \"Nodata\" , \"band_descriptions\" : [[ 1 , \"band1\" ]], \"dtype\" : \"int8\" , \"colorinterp\" : [ \"palette\" ], \"colormap\" : { \"0\" : [ 0 , 0 , 0 , 0 ], \"1\" : [ 0 , 61 , 0 , 255 ], \"2\" : [ 148 , 56 , 112 , 255 ], ... } } colormaps \u00b6 In addition to a new colormap specific submodule ( rio_tiler.colormap ), in rio-tiler==2 , colormaps are now RGBA values. We also removed PIL colormap compatibility. # v1 cmap = rio_tiler . utils . get_colormap ( \"viridis\" , format = \"gdal\" ) print ( cmap [ 0 ]) > [ 68 , 1 , 84 ] # v2 cmap = rio_tiler . colormap . get_colormap ( \"viridis\" ) print ( cmap [ 0 ]) > [ 68 , 1 , 84 , 255 ] render \u00b6 In rio-tiler==1. * to create an image blob from an array we used the rio_tiler.utils.array_to_image function. We have renamed and slightly refactored the function but it works the same. # v1 img = rio_tiler . utils . array_to_image ( tile , mask , img_format = \"PNG\" ) # v2 img = rio_tiler . utils . render ( tile , mask , img_format = \"PNG\" ) Mission specific changes \u00b6 Mission-specific tilers have been moved to the rio-tiler-pds package. Each rio_tiler.io.{mission} scene id parser (e.g cbers_parser) has been refactored and now return AWS S3 path information. rio_tiler . io . landsat8 . landsat_parser ( \"LC08_L1TP_016037_20170813_20170814_01_RT\" )) { \"sensor\" : \"C\" , \"satellite\" : \"08\" , \"processingCorrectionLevel\" : \"L1TP\" , \"path\" : \"016\" , \"row\" : \"037\" , \"acquisitionYear\" : \"2017\" , \"acquisitionMonth\" : \"08\" , \"acquisitionDay\" : \"13\" , \"processingYear\" : \"2017\" , \"processingMonth\" : \"08\" , \"processingDay\" : \"14\" , \"collectionNumber\" : \"01\" , \"collectionCategory\" : \"RT\" , \"scene\" : \"LC08_L1TP_016037_20170813_20170814_01_RT\" , \"date\" : \"2017-08-13\" , --> \"scheme\" : \"s3\" , --> \"bucket\" : \"landsat-pds\" , --> \"prefix\" : \"c1/L8/016/037/LC08_L1TP_016037_20170813_20170814_01_RT\" }","title":"Migration from v1.0 to v2.0"},{"location":"v2_migration/#python-3-only","text":"First and foremost is the drop of Python 2 support. We are in 2020 and Python 2 is officially dead . For ease of maintenance we decided to remove Python 2 support and to continue with only Python 3. Python 3.5 or later is required. If you need help moving from Python 2 to 3 check out the official transition documentation .","title":"Python 3 only"},{"location":"v2_migration/#type-hints","text":"As part of switching to Python 3, we also embraced modern code style with the adoption of type hints. Python 3.6+ has new syntax support for optional \"type hinting\" -- declaring the type of a variable -- which enables an improved development experience in editors and tools. This does not require any changes to your code as long as you're using Python 3.6+. For more information see: fastapi.tiangolo.com/python-types/ kishstats.com/python/2019/01/07/python-type-hinting.html mypy.readthedocs.io/en/stable/cheat_sheet_py3.html Typing example: def get_vrt_transform ( src_dst : Union [ DatasetReader , DatasetWriter , WarpedVRT ], bounds : Tuple [ float , float , float , float ], dst_crs : CRS = constants . WEB_MERCATOR_CRS , ) -> Tuple [ Affine , int , int ]:","title":"Type hints"},{"location":"v2_migration/#rasterio-113","text":"Rasterio 1.1.3 or newer is required. Recent changes in rasterio makes masking more reliable.","title":"Rasterio &gt;= 1.1.3"},{"location":"v2_migration/#new-rio_tilerio-submodules","text":"We created revised submodules for working with COGs and STAC: rio_tiler.io.cogeo is a modified version of the previous rio_tiler.main.tile . rio_tiler.io.stac is a new module to work with SpatioTemporal Asset Catalogs (STAC) . We now support reading files through a ContextManager to enable accessing the source rasterio dataset. # v1 from rio_tiler.main import tile as cogTiler tile , mask = cogTiler ( 'my_tif.tif' , 691559 , 956905 , 21 , tilesize = 256 ) # v2 from rio_tiler.io import COGReader with COGReader ( \"my_tif.tif\" ) as cog : tile , mask = cog . tile ( 691559 , 956905 , 21 , tilesize = 256 ) print ( cog . dataset ) # rasterio dataset (returned by rasterio.open()) print ( cog . dataset . meta ) # rasterio metadata print ( cog . bounds ) # WGS84 bounds print ( cog . colormap ) # internal colormap Expression support is now directly available in the COGReader with COGReader ( \"my_tif.tif\" ) as cog : tile , mask = cog . tile ( 691559 , 956905 , 21 , expression = \"b1/b2\" )","title":"New rio_tiler.io submodules"},{"location":"v2_migration/#cogreader-description","text":"class COGReader : \"\"\" Cloud Optimized GeoTIFF Reader. Examples -------- with COGReader(src_path) as cog: cog.tile(...) with rasterio.open(src_path) as src_dst: with WarpedVRT(src_dst, ...) as vrt_dst: with COGReader(None, dataset=vrt_dst) as cog: cog.tile(...) with rasterio.open(src_path) as src_dst: with COGReader(None, dataset=src_dst) as cog: cog.tile(...) Attributes ---------- filepath: str Cloud Optimized GeoTIFF path. dataset: rasterio.DatasetReader, optional Rasterio dataset. Properties ---------- minzoom: int COG minimum zoom level. maxzoom: int COG maximum zoom level. bounds: tuple[float] COG bounds in WGS84 crs. center: tuple[float, float, int] COG center + minzoom colormap: dict COG internal colormap. info: dict General information about the COG (datatype, indexes, ...) Methods ------- tile(0, 0, 0, indexes=(1,2,3), expression=\"\u001dB1/B2\", tilesize=512, resampling_methods=\"nearest\") Read a map tile from the COG. part((0,10,0,10), indexes=(1,2,3,), expression=\"\u001dB1/B20\", max_size=1024) Read part of the COG. preview(max_size=1024) Read preview of the COG. point((10, 10), indexes=1) Read a point value from the COG. stats(pmin=5, pmax=95) Get Raster statistics. meta(pmin=5, pmax=95) Get info + raster statistics \"\"\"","title":"COGReader description"},{"location":"v2_migration/#internal-api-rio_tilerreader","text":"Internal tile/data reading functions have been refactored and moved to a new rio_tiler.reader submodule.","title":"Internal API: rio_tiler.reader"},{"location":"v2_migration/#tile","text":"In rio_tiler==1 most of the magic was happening in rio_tiler.utils._tile_read . In rio_tiler==2 this function is now split in two, rio_tiler.reader.part and rio_tiler_reader._read , to reduce code reutilisation and to make the code more robust. The part function now takes height and width instead of a unique tilesize to specify the output array size. To ease the transition we added a rio_tiler.reader.tile function. Note: The new rio_tiler.reader.part function enables to perform non-squared data cropping by passing output width and height (instead of just tilesize). # v1 with rasterio . open ( \"my_tif.tif\" ) as src_dst : # get tile bounds and read raster mercator_tile = mercantile . Tile ( x = tile_x , y = tile_y , z = tile_z ) tile_bounds = mercantile . xy_bounds ( mercator_tile ) t , m = rio_tiler . utils . _tile_read ( src , tile_bounds , 256 ) # v2 with rasterio . open ( \"my_tif.tif\" ) as src_dst : t , m = rio_tiler . reader . tile ( src_dst , tile_x , tile_y , tile_z , 256 ) # Will check if tile is valid # Or with rasterio . open ( \"my_tif.tif\" ) as src_dst : mercator_tile = mercantile . Tile ( x = tile_x , y = tile_y , z = tile_z ) tile_bounds = mercantile . xy_bounds ( mercator_tile ) t , m = rio_tiler . reader . part ( src_dst , tile_bounds , 256 , 256 ) Options changes - tile_edge_padding -> padding , and set to 0 by default - minimum_tile_cover -> minimum_overlap - unscale ( New ): add ability to apply scale and offset to the data (Default: False) # v1 with rasterio . open ( \"my_tif.tif\" ) as src_dst : mercator_tile = mercantile . Tile ( x = tile_x , y = tile_y , z = tile_z ) tile_bounds = mercantile . xy_bounds ( mercator_tile ) t , m = rio_tiler . utils . _tile_read ( src , tile_bounds , 256 , tile_edge_padding = 4 , minimum_tile_cover = 0.3 ) # v2 with rasterio . open ( \"my_tif.tif\" ) as src_dst : t , m = rio_tiler . reader . tile ( src_dst , tile_x , tile_y , tile_z , 256 , padding = 4 , minimum_overlap = 0.3 )","title":"tile"},{"location":"v2_migration/#alpha-band","text":"Since the first version, rio-tiler returns a tuple of (data, mask) in most of the reading function. This design was made early and without thinking about datasets with an alpha channel, which resulted in issues like #126 , where a user gets a 4 bands data array + a mask (instead of 3 bands + mask). In rio-tiler=2. , when no indexes options are passed, we remove the alpha channel from the output data array. # v1 with rasterio . open ( \"my_tif_alpha.tif\" ) as src_dst : t , m = rio_tiler . utils . _tile_read ( src , tile_bounds , 256 , indexes = ( 1 , 2 , 3 )) # v2 with rasterio . open ( \"my_tif_alpha.tif\" ) as src_dst : # because rio-tiler will remove the alpha band we don't need to use the indexes option t , m = rio_tiler . reader . tile ( src_dst , tile_x , tile_y , tile_z , 256 )","title":"Alpha band"},{"location":"v2_migration/#metadata","text":"rio_tiler.utils._raster_get_stats has been replaced by rio_tiler.reader.metadata which uses the new reader.part and reader.preview functions. Meaning that now you can get metadata for a specific area by passing a bbox. To limit the data transfer (with the idea of getting the metadata from the COG overviews) we use only the max_size options, meaning the overview_level options have been removed (at least for version 2.0.0). # v1 import rio_tiler with rasterio . open ( \"my_tif.tif\" ) as src_dst : meta = rio_tiler . utils . _raster_get_stats ( src_dst ) # v2 with rasterio . open ( \"my_tif.tif\" ) as src_dst : rio_tiler . reader . metadata ( src_dst ) Options changes - removed histogram_bins and histogram_range which should now be passed in hist_options (e.g: hist_options={bins=10, range=(0, 10)}) - removed overview_level - added bounds Output The output has also been updated. The new metadata output doesn't return min/max zoom and bounds is return in WGS84 by default. # v1 with rasterio . open ( \"my_tif.tif\" ) as src_dst : rio_tiler . utils . _raster_get_stats ( src_dst ) > { \"bounds\" : { \"value\" : [ - 119.05915661478785 , 13.102845359730287 , - 84.91821332299578 , 33.995073647795806 ], \"crs\" : \"EPSG:4326\" }, \"minzoom\" : 3 , \"maxzoom\" : 12 , \"band_descriptions\" : [ [ 1 , \"band1\" ] ], \"statistics\" : { \"1\" : { \"pc\" : [ 1 , 17 ], \"min\" : 1 , \"max\" : 18 , \"std\" : 4.418616203143802 , \"histogram\" : [ [ ... ], [ ... ] ] } } } # v2 with rasterio . open ( \"my_tif.tif\" ) as src_dst : rio_tiler . reader . metadata ( src_dst ) > { \"bounds\" : [ - 119.05915661478785 , 13.102845359730287 , - 84.91821332299578 , 33.995073647795806 ], \"statistics\" : { \"1\" : { \"pc\" : [ 1 , 16 ], \"min\" : 1 , \"max\" : 18 , \"std\" : 4.069636227214257 , \"histogram\" : [ [ ... ], [ ... ] ] } }, \"nodata_type\" : \"Nodata\" , \"band_descriptions\" : [[ 1 , \"band1\" ]], \"dtype\" : \"int8\" , \"colorinterp\" : [ \"palette\" ], \"colormap\" : { \"0\" : [ 0 , 0 , 0 , 0 ], \"1\" : [ 0 , 61 , 0 , 255 ], \"2\" : [ 148 , 56 , 112 , 255 ], ... } }","title":"metadata"},{"location":"v2_migration/#colormaps","text":"In addition to a new colormap specific submodule ( rio_tiler.colormap ), in rio-tiler==2 , colormaps are now RGBA values. We also removed PIL colormap compatibility. # v1 cmap = rio_tiler . utils . get_colormap ( \"viridis\" , format = \"gdal\" ) print ( cmap [ 0 ]) > [ 68 , 1 , 84 ] # v2 cmap = rio_tiler . colormap . get_colormap ( \"viridis\" ) print ( cmap [ 0 ]) > [ 68 , 1 , 84 , 255 ]","title":"colormaps"},{"location":"v2_migration/#render","text":"In rio-tiler==1. * to create an image blob from an array we used the rio_tiler.utils.array_to_image function. We have renamed and slightly refactored the function but it works the same. # v1 img = rio_tiler . utils . array_to_image ( tile , mask , img_format = \"PNG\" ) # v2 img = rio_tiler . utils . render ( tile , mask , img_format = \"PNG\" )","title":"render"},{"location":"v2_migration/#mission-specific-changes","text":"Mission-specific tilers have been moved to the rio-tiler-pds package. Each rio_tiler.io.{mission} scene id parser (e.g cbers_parser) has been refactored and now return AWS S3 path information. rio_tiler . io . landsat8 . landsat_parser ( \"LC08_L1TP_016037_20170813_20170814_01_RT\" )) { \"sensor\" : \"C\" , \"satellite\" : \"08\" , \"processingCorrectionLevel\" : \"L1TP\" , \"path\" : \"016\" , \"row\" : \"037\" , \"acquisitionYear\" : \"2017\" , \"acquisitionMonth\" : \"08\" , \"acquisitionDay\" : \"13\" , \"processingYear\" : \"2017\" , \"processingMonth\" : \"08\" , \"processingDay\" : \"14\" , \"collectionNumber\" : \"01\" , \"collectionCategory\" : \"RT\" , \"scene\" : \"LC08_L1TP_016037_20170813_20170814_01_RT\" , \"date\" : \"2017-08-13\" , --> \"scheme\" : \"s3\" , --> \"bucket\" : \"landsat-pds\" , --> \"prefix\" : \"c1/L8/016/037/LC08_L1TP_016037_20170813_20170814_01_RT\" }","title":"Mission specific changes"},{"location":"advanced/dynamic_tiler/","text":"rio-tiler aims to be a lightweight plugin for rasterio whose sole goal is to read a Mercator Tile from a raster dataset. Given that rio-tiler allows for simple, efficient reading of tiles, you can then leverage rio-tiler to create a dynamic tile server to display raster tiles on a web map. There are couple tile servers built on top of rio-tiler: titiler cogeo-tiler cogeo-mosaic-tiler rio-viz Example Application \u00b6 To build a simple dynamic tiling application, we can use FastAPI . Note that titiler uses FastAPI internally, so you might consider using titiler instead of making your own API. Requirements \u00b6 rio-tiler ~= 2.0b fastapi uvicorn Install with pip install fastapi uvicorn 'rio-tiler~=2.0b' app.py \u00b6 \"\"\"rio-tiler tile server.\"\"\" import os from enum import Enum from typing import Any , Dict , List , Optional from urllib.parse import urlencode import uvicorn from fastapi import FastAPI , Path , Query from rasterio.crs import CRS from starlette.background import BackgroundTask from starlette.middleware.cors import CORSMiddleware from starlette.middleware.gzip import GZipMiddleware from starlette.requests import Request from starlette.responses import Response from rio_tiler.profiles import img_profiles from rio_tiler.utils import render from rio_tiler.io import COGReader # From developmentseed/titiler drivers = dict ( jpg = \"JPEG\" , png = \"PNG\" ) mimetype = dict ( png = \"image/png\" , jpg = \"image/jpg\" ,) class ImageType ( str , Enum ): \"\"\"Image Type Enums.\"\"\" png = \"png\" jpg = \"jpg\" class TileResponse ( Response ): \"\"\"Tiler's response.\"\"\" def __init__ ( self , content : bytes , media_type : str , status_code : int = 200 , headers : dict = {}, background : BackgroundTask = None , ttl : int = 3600 , ) -> None : \"\"\"Init tiler response.\"\"\" headers . update ({ \"Content-Type\" : media_type }) if ttl : headers . update ({ \"Cache-Control\" : \"max-age=3600\" }) self . body = self . render ( content ) self . status_code = 200 self . media_type = media_type self . background = background self . init_headers ( headers ) app = FastAPI ( title = \"rio-tiler\" , description = \"A lightweight Cloud Optimized GeoTIFF tile server\" , ) app . add_middleware ( CORSMiddleware , allow_origins = [ \"*\" ], allow_credentials = True , allow_methods = [ \"GET\" ], allow_headers = [ \"*\" ], ) app . add_middleware ( GZipMiddleware , minimum_size = 0 ) responses = { 200 : { \"content\" : { \"image/png\" : {}, \"image/jpg\" : {}}, \"description\" : \"Return an image.\" , } } tile_routes_params : Dict [ str , Any ] = dict ( responses = responses , tags = [ \"tiles\" ], response_class = TileResponse ) @app . get ( \"/ {z} / {x} / {y} \" , ** tile_routes_params ) def tile ( z : int , x : int , y : int , url : str = Query ( ... , description = \"Cloud Optimized GeoTIFF URL.\" ), ): \"\"\"Handle tiles requests.\"\"\" with COGReader ( url ) as cog : tile , mask = cog . tile ( x , y , z , tilesize = 256 ) format = ImageType . jpg if mask . all () else ImageType . png driver = drivers [ format . value ] options = img_profiles . get ( driver . lower (), {}) img = render ( tile , mask , img_format = driver , ** options ) return TileResponse ( img , media_type = mimetype [ format . value ]) @app . get ( \"/tilejson.json\" , responses = { 200 : { \"description\" : \"Return a tilejson\" }}) def tilejson ( request : Request , url : str = Query ( ... , description = \"Cloud Optimized GeoTIFF URL.\" ), minzoom : Optional [ int ] = Query ( None , description = \"Overwrite default minzoom.\" ), maxzoom : Optional [ int ] = Query ( None , description = \"Overwrite default maxzoom.\" ), ): \"\"\"Return TileJSON document for a COG.\"\"\" tile_url = request . url_for ( \"tile\" , { \"z\" : \" {z} \" , \"x\" : \" {x} \" , \"y\" : \" {y} \" }) . replace ( \" \\\\ \" , \"\" ) kwargs = dict ( request . query_params ) kwargs . pop ( \"tile_format\" , None ) kwargs . pop ( \"tile_scale\" , None ) kwargs . pop ( \"minzoom\" , None ) kwargs . pop ( \"maxzoom\" , None ) qs = urlencode ( list ( kwargs . items ())) tile_url = f \" { tile_url } ? { qs } \" with COGReader ( url ) as cog : center = list ( cog . center ) if minzoom : center [ - 1 ] = minzoom tjson = { \"bounds\" : cog . bounds , \"center\" : tuple ( center ), \"minzoom\" : minzoom or cog . minzoom , \"maxzoom\" : maxzoom or cog . maxzoom , \"name\" : os . path . basename ( url ), \"tiles\" : [ tile_url ], } return tjson Launch Example \u00b6 Use uvicorn to launch the application. Note that app:app tells uvicorn to call the app function within app.py , so you must be in the same directory as app.py . uvicorn app:app --reload Create an AWS Lambda package \u00b6 The easiest way to make sure the package will work on AWS is to use docker FROM lambci/lambda:build-python3.7 ENV LANG = en_US.UTF-8 LC_ALL = en_US.UTF-8 CFLAGS = \"--std=c99\" RUN pip3 install rio-tiler --no-binary numpy -t /tmp/python -U RUN cd /tmp/python && zip -r9q /tmp/package.zip * Ref: vincentsarago/simple-rio-lambda","title":"Create a Dynamic Tiler"},{"location":"advanced/dynamic_tiler/#example-application","text":"To build a simple dynamic tiling application, we can use FastAPI . Note that titiler uses FastAPI internally, so you might consider using titiler instead of making your own API.","title":"Example Application"},{"location":"advanced/dynamic_tiler/#requirements","text":"rio-tiler ~= 2.0b fastapi uvicorn Install with pip install fastapi uvicorn 'rio-tiler~=2.0b'","title":"Requirements"},{"location":"advanced/dynamic_tiler/#apppy","text":"\"\"\"rio-tiler tile server.\"\"\" import os from enum import Enum from typing import Any , Dict , List , Optional from urllib.parse import urlencode import uvicorn from fastapi import FastAPI , Path , Query from rasterio.crs import CRS from starlette.background import BackgroundTask from starlette.middleware.cors import CORSMiddleware from starlette.middleware.gzip import GZipMiddleware from starlette.requests import Request from starlette.responses import Response from rio_tiler.profiles import img_profiles from rio_tiler.utils import render from rio_tiler.io import COGReader # From developmentseed/titiler drivers = dict ( jpg = \"JPEG\" , png = \"PNG\" ) mimetype = dict ( png = \"image/png\" , jpg = \"image/jpg\" ,) class ImageType ( str , Enum ): \"\"\"Image Type Enums.\"\"\" png = \"png\" jpg = \"jpg\" class TileResponse ( Response ): \"\"\"Tiler's response.\"\"\" def __init__ ( self , content : bytes , media_type : str , status_code : int = 200 , headers : dict = {}, background : BackgroundTask = None , ttl : int = 3600 , ) -> None : \"\"\"Init tiler response.\"\"\" headers . update ({ \"Content-Type\" : media_type }) if ttl : headers . update ({ \"Cache-Control\" : \"max-age=3600\" }) self . body = self . render ( content ) self . status_code = 200 self . media_type = media_type self . background = background self . init_headers ( headers ) app = FastAPI ( title = \"rio-tiler\" , description = \"A lightweight Cloud Optimized GeoTIFF tile server\" , ) app . add_middleware ( CORSMiddleware , allow_origins = [ \"*\" ], allow_credentials = True , allow_methods = [ \"GET\" ], allow_headers = [ \"*\" ], ) app . add_middleware ( GZipMiddleware , minimum_size = 0 ) responses = { 200 : { \"content\" : { \"image/png\" : {}, \"image/jpg\" : {}}, \"description\" : \"Return an image.\" , } } tile_routes_params : Dict [ str , Any ] = dict ( responses = responses , tags = [ \"tiles\" ], response_class = TileResponse ) @app . get ( \"/ {z} / {x} / {y} \" , ** tile_routes_params ) def tile ( z : int , x : int , y : int , url : str = Query ( ... , description = \"Cloud Optimized GeoTIFF URL.\" ), ): \"\"\"Handle tiles requests.\"\"\" with COGReader ( url ) as cog : tile , mask = cog . tile ( x , y , z , tilesize = 256 ) format = ImageType . jpg if mask . all () else ImageType . png driver = drivers [ format . value ] options = img_profiles . get ( driver . lower (), {}) img = render ( tile , mask , img_format = driver , ** options ) return TileResponse ( img , media_type = mimetype [ format . value ]) @app . get ( \"/tilejson.json\" , responses = { 200 : { \"description\" : \"Return a tilejson\" }}) def tilejson ( request : Request , url : str = Query ( ... , description = \"Cloud Optimized GeoTIFF URL.\" ), minzoom : Optional [ int ] = Query ( None , description = \"Overwrite default minzoom.\" ), maxzoom : Optional [ int ] = Query ( None , description = \"Overwrite default maxzoom.\" ), ): \"\"\"Return TileJSON document for a COG.\"\"\" tile_url = request . url_for ( \"tile\" , { \"z\" : \" {z} \" , \"x\" : \" {x} \" , \"y\" : \" {y} \" }) . replace ( \" \\\\ \" , \"\" ) kwargs = dict ( request . query_params ) kwargs . pop ( \"tile_format\" , None ) kwargs . pop ( \"tile_scale\" , None ) kwargs . pop ( \"minzoom\" , None ) kwargs . pop ( \"maxzoom\" , None ) qs = urlencode ( list ( kwargs . items ())) tile_url = f \" { tile_url } ? { qs } \" with COGReader ( url ) as cog : center = list ( cog . center ) if minzoom : center [ - 1 ] = minzoom tjson = { \"bounds\" : cog . bounds , \"center\" : tuple ( center ), \"minzoom\" : minzoom or cog . minzoom , \"maxzoom\" : maxzoom or cog . maxzoom , \"name\" : os . path . basename ( url ), \"tiles\" : [ tile_url ], } return tjson","title":"app.py"},{"location":"advanced/dynamic_tiler/#launch-example","text":"Use uvicorn to launch the application. Note that app:app tells uvicorn to call the app function within app.py , so you must be in the same directory as app.py . uvicorn app:app --reload","title":"Launch Example"},{"location":"advanced/dynamic_tiler/#create-an-aws-lambda-package","text":"The easiest way to make sure the package will work on AWS is to use docker FROM lambci/lambda:build-python3.7 ENV LANG = en_US.UTF-8 LC_ALL = en_US.UTF-8 CFLAGS = \"--std=c99\" RUN pip3 install rio-tiler --no-binary numpy -t /tmp/python -U RUN cd /tmp/python && zip -r9q /tmp/package.zip * Ref: vincentsarago/simple-rio-lambda","title":"Create an AWS Lambda package"},{"location":"advanced/feature/","text":"Natively rio-tiler support mostly bbox reading. Using GDALWarpVRT Cutline option, it's possible to read a dataset for a given polygon. from rio_tiler.io import COGReader from rio_tiler.utils import create_cutline from rasterio.features import bounds as featureBounds feat = { \"type\" : \"Feature\" , \"properties\" : {}, \"geometry\" : { \"type\" : \"Polygon\" , \"coordinates\" : [ [ [ - 52.6025390625 , 73.86761239709705 ], [ - 52.6025390625 , 73.59679245247814 ], [ - 51.591796875 , 73.60299628304274 ], [ - 51.591796875 , 73.90420357134279 ], [ - 52.4267578125 , 74.0437225981325 ], [ - 52.6025390625 , 73.86761239709705 ] ] ] } } # Get BBOX of the polygon bbox = featureBounds ( feat ) # Use COGReader to open and read the dataset with COGReader ( \"my_tif.tif\" ) as cog : # Create WTT Cutline cutline = create_cutline ( cog . dataset , feat , geometry_crs = \"epsg:4326\" ) # Read part of the data (bbox) and use the cutline to mask the data data , mask = cog . part ( bbox , vrt_options = { 'cutline' : cutline }) The previous example uses the .part method but any method that uses the rio_tiler.reader._read function will accept the cutline options. bbox = featureBounds ( feat ) # Use COGReader to open and read the dataset with COGReader ( \"my_tif.tif\" ) as cog : # Create WTT Cutline cutline = create_cutline ( cog . dataset , feat , geometry_crs = \"epsg:4326\" ) # Get a preview of the whole geotiff but use the cutline to mask the data data , mask = cog . preview ( vrt_options = { 'cutline' : cutline }) # Read a mercator tile and use the cutline to mask the data data , mask = cog . tile ( 1 , 1 , 1 , vrt_options = { 'cutline' : cutline }) # Get image statistics over a bbox and use the cutline as mask stats = cog . stats ( bounds = bbox , vrt_options = { 'cutline' : cutline })","title":"Use a Feature to read a COG"},{"location":"advanced/multi_assets/","text":"rio_tiler.io.cogeo submodule has multi_* functions (tile, part, preview, point, metadata, info, stats) allowing to fetch and merge info/data from multiple dataset (think about multiple bands stored in separated files). from typing import Dict from rio_tiler.io.cogeo import multi_tile assets = [ \"b1.tif\" , \"b2.tif\" , \"b3.tif\" ] tile , mask = multi_tile ( assets , x , y , z , tilesize = 256 ) print ( tile . shape ) > ( 3 , 256 , 256 ) # Others metadata = multi_info ( assets ) stats = multi_stats ( assets , pmin = 2 , pmax = 98 , ... ) metadata = multi_metadata ( assets , pmin = 2 , pmax = 98 , ... ) values = multi_points ( assets , lon , lat , ... ) data , mask = multi_part ( assets , bbox , ... ) data , mask = multi_preview ( assets , ... ) You can also use rio_tiler.io.base.MultiBaseReader to build a custom asset reader: import attr from rio_tiler.io.base import MultiBaseReader from rio_tiler.io import COGReader , BaseReader # CustomReader is a subclass of MultiBaseReader. # To ease the creation of the class and because MultiBaseReader is built with `attr` # we also need to add the `@attr.s` wrapper on top of our custom class. @attr . s class CustomReader ( MultiBaseReader ): directory : str = attr . ib () # required arg reader : Type [ BaseReader ] = attr . ib ( default = COGReader ) # the default reader is COGReader def __enter__ ( self ): # List files in directory dirs = os . listdir ( self . directory ) # get list of tifs tiff = [ f for f in dirs if f . endswith ( \".tif\" )] # create list of assets names - REQUIRED self . assets = [ os . path . basename ( f ) . split ( \".\" )[ 0 ] for f in tiff ] # `self.bounds` needs to be set! - REQUIRED with self . reader ( tiff [ 0 ]) as cog : self . bounds = cog . bounds return self def _get_asset_url ( self , asset : str ) -> str : \"\"\"Validate asset names and return asset's url.\"\"\" if asset not in self . assets : raise InvalidAssetName ( f \" { asset } is not valid\" ) return os . path . join ( self . directory , f \" { asset } .tif\" ) # we have a directoty with \"b1.tif\", \"b2.tif\", \"b3.tif\" with CustomReader ( \"my_dir/\" ) as cr : print ( cr . assets ) tile , mask = cr . tile ( x , y , z , assets = \"b1\" ) > [ \"b1\" , \"b2\" , \"b3\" ] print ( tile . shape ) > ( 3 , 256 , 256 )","title":"Working with multiple assets"},{"location":"examples/Using-rio-tiler-mosaic/","text":"/*! * * IPython notebook * */ /* CSS font colors for translated ANSI escape sequences */ /* The color values are a mix of http://www.xcolors.net/dl/baskerville-ivorylight and http://www.xcolors.net/dl/euphrasia */ .ansi-black-fg { color: #3E424D; } .ansi-black-bg { background-color: #3E424D; } .ansi-black-intense-fg { color: #282C36; } .ansi-black-intense-bg { background-color: #282C36; } .ansi-red-fg { color: #E75C58; } .ansi-red-bg { background-color: #E75C58; } .ansi-red-intense-fg { color: #B22B31; } .ansi-red-intense-bg { background-color: #B22B31; } .ansi-green-fg { color: #00A250; } .ansi-green-bg { background-color: #00A250; } .ansi-green-intense-fg { color: #007427; } .ansi-green-intense-bg { background-color: #007427; } .ansi-yellow-fg { color: #DDB62B; } .ansi-yellow-bg { background-color: #DDB62B; } .ansi-yellow-intense-fg { color: #B27D12; } .ansi-yellow-intense-bg { background-color: #B27D12; } .ansi-blue-fg { color: #208FFB; } .ansi-blue-bg { background-color: #208FFB; } .ansi-blue-intense-fg { color: #0065CA; } .ansi-blue-intense-bg { background-color: #0065CA; } .ansi-magenta-fg { color: #D160C4; } .ansi-magenta-bg { background-color: #D160C4; } .ansi-magenta-intense-fg { color: #A03196; } .ansi-magenta-intense-bg { background-color: #A03196; } .ansi-cyan-fg { color: #60C6C8; } .ansi-cyan-bg { background-color: #60C6C8; } .ansi-cyan-intense-fg { color: #258F8F; } .ansi-cyan-intense-bg { background-color: #258F8F; } .ansi-white-fg { color: #C5C1B4; } .ansi-white-bg { background-color: #C5C1B4; } .ansi-white-intense-fg { color: #A1A6B2; } .ansi-white-intense-bg { background-color: #A1A6B2; } .ansi-default-inverse-fg { color: #FFFFFF; } .ansi-default-inverse-bg { background-color: #000000; } .ansi-bold { font-weight: bold; } .ansi-underline { text-decoration: underline; } /* The following styles are deprecated an will be removed in a future version */ .ansibold { font-weight: bold; } .ansi-inverse { outline: 0.5px dotted; } /* use dark versions for foreground, to improve visibility */ .ansiblack { color: black; } .ansired { color: darkred; } .ansigreen { color: darkgreen; } .ansiyellow { color: #c4a000; } .ansiblue { color: darkblue; } .ansipurple { color: darkviolet; } .ansicyan { color: steelblue; } .ansigray { color: gray; } /* and light for background, for the same reason */ .ansibgblack { background-color: black; } .ansibgred { background-color: red; } .ansibggreen { background-color: green; } .ansibgyellow { background-color: yellow; } .ansibgblue { background-color: blue; } .ansibgpurple { background-color: magenta; } .ansibgcyan { background-color: cyan; } .ansibggray { background-color: gray; } div.cell { /* Old browsers */ display: -webkit-box; -webkit-box-orient: vertical; -webkit-box-align: stretch; display: -moz-box; -moz-box-orient: vertical; -moz-box-align: stretch; display: box; box-orient: vertical; box-align: stretch; /* Modern browsers */ display: flex; flex-direction: column; align-items: stretch; border-radius: 2px; box-sizing: border-box; -moz-box-sizing: border-box; -webkit-box-sizing: border-box; border-width: 1px; border-style: solid; border-color: transparent; width: 100%; padding: 5px; /* This acts as a spacer between cells, that is outside the border */ margin: 0px; outline: none; position: relative; overflow: visible; } div.cell:before { position: absolute; display: block; top: -1px; left: -1px; width: 5px; height: calc(100% + 2px); content: ''; background: transparent; } div.cell.jupyter-soft-selected { border-left-color: #E3F2FD; border-left-width: 1px; padding-left: 5px; border-right-color: #E3F2FD; border-right-width: 1px; background: #E3F2FD; } @media print { div.cell.jupyter-soft-selected { border-color: transparent; } } div.cell.selected, div.cell.selected.jupyter-soft-selected { border-color: #ababab; } div.cell.selected:before, div.cell.selected.jupyter-soft-selected:before { position: absolute; display: block; top: -1px; left: -1px; width: 5px; height: calc(100% + 2px); content: ''; background: #42A5F5; } @media print { div.cell.selected, div.cell.selected.jupyter-soft-selected { border-color: transparent; } } .edit_mode div.cell.selected { border-color: #66BB6A; } .edit_mode div.cell.selected:before { position: absolute; display: block; top: -1px; left: -1px; width: 5px; height: calc(100% + 2px); content: ''; background: #66BB6A; } @media print { .edit_mode div.cell.selected { border-color: transparent; } } .prompt { /* This needs to be wide enough for 3 digit prompt numbers: In[100]: */ min-width: 14ex; /* This padding is tuned to match the padding on the CodeMirror editor. */ padding: 0.4em; margin: 0px; font-family: monospace; text-align: right; /* This has to match that of the the CodeMirror class line-height below */ line-height: 1.21429em; /* Don't highlight prompt number selection */ -webkit-touch-callout: none; -webkit-user-select: none; -khtml-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none; /* Use default cursor */ cursor: default; } @media (max-width: 540px) { .prompt { text-align: left; } } div.inner_cell { min-width: 0; /* Old browsers */ display: -webkit-box; -webkit-box-orient: vertical; -webkit-box-align: stretch; display: -moz-box; -moz-box-orient: vertical; -moz-box-align: stretch; display: box; box-orient: vertical; box-align: stretch; /* Modern browsers */ display: flex; flex-direction: column; align-items: stretch; /* Old browsers */ -webkit-box-flex: 1; -moz-box-flex: 1; box-flex: 1; /* Modern browsers */ flex: 1; } /* input_area and input_prompt must match in top border and margin for alignment */ div.input_area { border: 1px solid #cfcfcf; border-radius: 2px; background: #f7f7f7; line-height: 1.21429em; } /* This is needed so that empty prompt areas can collapse to zero height when there is no content in the output_subarea and the prompt. The main purpose of this is to make sure that empty JavaScript output_subareas have no height. */ div.prompt:empty { padding-top: 0; padding-bottom: 0; } div.unrecognized_cell { padding: 5px 5px 5px 0px; /* Old browsers */ display: -webkit-box; -webkit-box-orient: horizontal; -webkit-box-align: stretch; display: -moz-box; -moz-box-orient: horizontal; -moz-box-align: stretch; display: box; box-orient: horizontal; box-align: stretch; /* Modern browsers */ display: flex; flex-direction: row; align-items: stretch; } div.unrecognized_cell .inner_cell { border-radius: 2px; padding: 5px; font-weight: bold; color: red; border: 1px solid #cfcfcf; background: #eaeaea; } div.unrecognized_cell .inner_cell a { color: inherit; text-decoration: none; } div.unrecognized_cell .inner_cell a:hover { color: inherit; text-decoration: none; } @media (max-width: 540px) { div.unrecognized_cell > div.prompt { display: none; } } div.code_cell { /* avoid page breaking on code cells when printing */ } @media print { div.code_cell { page-break-inside: avoid; } } /* any special styling for code cells that are currently running goes here */ div.input { page-break-inside: avoid; /* Old browsers */ display: -webkit-box; -webkit-box-orient: horizontal; -webkit-box-align: stretch; display: -moz-box; -moz-box-orient: horizontal; -moz-box-align: stretch; display: box; box-orient: horizontal; box-align: stretch; /* Modern browsers */ display: flex; flex-direction: row; align-items: stretch; } @media (max-width: 540px) { div.input { /* Old browsers */ display: -webkit-box; -webkit-box-orient: vertical; -webkit-box-align: stretch; display: -moz-box; -moz-box-orient: vertical; -moz-box-align: stretch; display: box; box-orient: vertical; box-align: stretch; /* Modern browsers */ display: flex; flex-direction: column; align-items: stretch; } } /* input_area and input_prompt must match in top border and margin for alignment */ div.input_prompt { color: #303F9F; border-top: 1px solid transparent; } div.input_area > div.highlight { margin: 0.4em; border: none; padding: 0px; background-color: transparent; } div.input_area > div.highlight > pre { margin: 0px; border: none; padding: 0px; background-color: transparent; } /* The following gets added to the <head> if it is detected that the user has a * monospace font with inconsistent normal/bold/italic height. See * notebookmain.js. Such fonts will have keywords vertically offset with * respect to the rest of the text. The user should select a better font. * See: https://github.com/ipython/ipython/issues/1503 * * .CodeMirror span { * vertical-align: bottom; * } */ .CodeMirror { line-height: 1.21429em; /* Changed from 1em to our global default */ font-size: 14px; height: auto; /* Changed to auto to autogrow */ background: none; /* Changed from white to allow our bg to show through */ } .CodeMirror-scroll { /* The CodeMirror docs are a bit fuzzy on if overflow-y should be hidden or visible.*/ /* We have found that if it is visible, vertical scrollbars appear with font size changes.*/ overflow-y: hidden; overflow-x: auto; } .CodeMirror-lines { /* In CM2, this used to be 0.4em, but in CM3 it went to 4px. We need the em value because */ /* we have set a different line-height and want this to scale with that. */ /* Note that this should set vertical padding only, since CodeMirror assumes that horizontal padding will be set on CodeMirror pre */ padding: 0.4em 0; } .CodeMirror-linenumber { padding: 0 8px 0 4px; } .CodeMirror-gutters { border-bottom-left-radius: 2px; border-top-left-radius: 2px; } .CodeMirror pre { /* In CM3 this went to 4px from 0 in CM2. This sets horizontal padding only, use .CodeMirror-lines for vertical */ padding: 0 0.4em; border: 0; border-radius: 0; } .CodeMirror-cursor { border-left: 1.4px solid black; } @media screen and (min-width: 2138px) and (max-width: 4319px) { .CodeMirror-cursor { border-left: 2px solid black; } } @media screen and (min-width: 4320px) { .CodeMirror-cursor { border-left: 4px solid black; } } /* Original style from softwaremaniacs.org (c) Ivan Sagalaev <Maniac@SoftwareManiacs.Org> Adapted from GitHub theme */ .highlight-base { color: #000; } .highlight-variable { color: #000; } .highlight-variable-2 { color: #1a1a1a; } .highlight-variable-3 { color: #333333; } .highlight-string { color: #BA2121; } .highlight-comment { color: #408080; font-style: italic; } .highlight-number { color: #080; } .highlight-atom { color: #88F; } .highlight-keyword { color: #008000; font-weight: bold; } .highlight-builtin { color: #008000; } .highlight-error { color: #f00; } .highlight-operator { color: #AA22FF; font-weight: bold; } .highlight-meta { color: #AA22FF; } /* previously not defined, copying from default codemirror */ .highlight-def { color: #00f; } .highlight-string-2 { color: #f50; } .highlight-qualifier { color: #555; } .highlight-bracket { color: #997; } .highlight-tag { color: #170; } .highlight-attribute { color: #00c; } .highlight-header { color: blue; } .highlight-quote { color: #090; } .highlight-link { color: #00c; } /* apply the same style to codemirror */ .cm-s-ipython span.cm-keyword { color: #008000; font-weight: bold; } .cm-s-ipython span.cm-atom { color: #88F; } .cm-s-ipython span.cm-number { color: #080; } .cm-s-ipython span.cm-def { color: #00f; } .cm-s-ipython span.cm-variable { color: #000; } .cm-s-ipython span.cm-operator { color: #AA22FF; font-weight: bold; } .cm-s-ipython span.cm-variable-2 { color: #1a1a1a; } .cm-s-ipython span.cm-variable-3 { color: #333333; } .cm-s-ipython span.cm-comment { color: #408080; font-style: italic; } .cm-s-ipython span.cm-string { color: #BA2121; } .cm-s-ipython span.cm-string-2 { color: #f50; } .cm-s-ipython span.cm-meta { color: #AA22FF; } .cm-s-ipython span.cm-qualifier { color: #555; } .cm-s-ipython span.cm-builtin { color: #008000; } .cm-s-ipython span.cm-bracket { color: #997; } .cm-s-ipython span.cm-tag { color: #170; } .cm-s-ipython span.cm-attribute { color: #00c; } .cm-s-ipython span.cm-header { color: blue; } .cm-s-ipython span.cm-quote { color: #090; } .cm-s-ipython span.cm-link { color: #00c; } .cm-s-ipython span.cm-error { color: #f00; } .cm-s-ipython span.cm-tab { background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAMCAYAAAAkuj5RAAAAAXNSR0IArs4c6QAAAGFJREFUSMft1LsRQFAQheHPowAKoACx3IgEKtaEHujDjORSgWTH/ZOdnZOcM/sgk/kFFWY0qV8foQwS4MKBCS3qR6ixBJvElOobYAtivseIE120FaowJPN75GMu8j/LfMwNjh4HUpwg4LUAAAAASUVORK5CYII=); background-position: right; background-repeat: no-repeat; } div.output_wrapper { /* this position must be relative to enable descendents to be absolute within it */ position: relative; /* Old browsers */ display: -webkit-box; -webkit-box-orient: vertical; -webkit-box-align: stretch; display: -moz-box; -moz-box-orient: vertical; -moz-box-align: stretch; display: box; box-orient: vertical; box-align: stretch; /* Modern browsers */ display: flex; flex-direction: column; align-items: stretch; z-index: 1; } /* class for the output area when it should be height-limited */ div.output_scroll { /* ideally, this would be max-height, but FF barfs all over that */ height: 24em; /* FF needs this *and the wrapper* to specify full width, or it will shrinkwrap */ width: 100%; overflow: auto; border-radius: 2px; -webkit-box-shadow: inset 0 2px 8px rgba(0, 0, 0, 0.8); box-shadow: inset 0 2px 8px rgba(0, 0, 0, 0.8); display: block; } /* output div while it is collapsed */ div.output_collapsed { margin: 0px; padding: 0px; /* Old browsers */ display: -webkit-box; -webkit-box-orient: vertical; -webkit-box-align: stretch; display: -moz-box; -moz-box-orient: vertical; -moz-box-align: stretch; display: box; box-orient: vertical; box-align: stretch; /* Modern browsers */ display: flex; flex-direction: column; align-items: stretch; } div.out_prompt_overlay { height: 100%; padding: 0px 0.4em; position: absolute; border-radius: 2px; } div.out_prompt_overlay:hover { /* use inner shadow to get border that is computed the same on WebKit/FF */ -webkit-box-shadow: inset 0 0 1px #000; box-shadow: inset 0 0 1px #000; background: rgba(240, 240, 240, 0.5); } div.output_prompt { color: #D84315; } /* This class is the outer container of all output sections. */ div.output_area { padding: 0px; page-break-inside: avoid; /* Old browsers */ display: -webkit-box; -webkit-box-orient: horizontal; -webkit-box-align: stretch; display: -moz-box; -moz-box-orient: horizontal; -moz-box-align: stretch; display: box; box-orient: horizontal; box-align: stretch; /* Modern browsers */ display: flex; flex-direction: row; align-items: stretch; } div.output_area .MathJax_Display { text-align: left !important; } div.output_area div.output_area div.output_area img, div.output_area svg { max-width: 100%; height: auto; } div.output_area img.unconfined, div.output_area svg.unconfined { max-width: none; } div.output_area .mglyph > img { max-width: none; } /* This is needed to protect the pre formating from global settings such as that of bootstrap */ .output { /* Old browsers */ display: -webkit-box; -webkit-box-orient: vertical; -webkit-box-align: stretch; display: -moz-box; -moz-box-orient: vertical; -moz-box-align: stretch; display: box; box-orient: vertical; box-align: stretch; /* Modern browsers */ display: flex; flex-direction: column; align-items: stretch; } @media (max-width: 540px) { div.output_area { /* Old browsers */ display: -webkit-box; -webkit-box-orient: vertical; -webkit-box-align: stretch; display: -moz-box; -moz-box-orient: vertical; -moz-box-align: stretch; display: box; box-orient: vertical; box-align: stretch; /* Modern browsers */ display: flex; flex-direction: column; align-items: stretch; } } div.output_area pre { margin: 0; padding: 1px 0 1px 0; border: 0; vertical-align: baseline; color: black; background-color: transparent; border-radius: 0; } /* This class is for the output subarea inside the output_area and after the prompt div. */ div.output_subarea { overflow-x: auto; padding: 0.4em; /* Old browsers */ -webkit-box-flex: 1; -moz-box-flex: 1; box-flex: 1; /* Modern browsers */ flex: 1; max-width: calc(100% - 14ex); } div.output_scroll div.output_subarea { overflow-x: visible; } /* The rest of the output_* classes are for special styling of the different output types */ /* all text output has this class: */ div.output_text { text-align: left; color: #000; /* This has to match that of the the CodeMirror class line-height below */ line-height: 1.21429em; } /* stdout/stderr are 'text' as well as 'stream', but execute_result/error are *not* streams */ div.output_stderr { background: #fdd; /* very light red background for stderr */ } div.output_latex { text-align: left; } /* Empty output_javascript divs should have no height */ div.output_javascript:empty { padding: 0; } .js-error { color: darkred; } /* raw_input styles */ div.raw_input_container { line-height: 1.21429em; padding-top: 5px; } pre.raw_input_prompt { /* nothing needed here. */ } input.raw_input { font-family: monospace; font-size: inherit; color: inherit; width: auto; /* make sure input baseline aligns with prompt */ vertical-align: baseline; /* padding + margin = 0.5em between prompt and cursor */ padding: 0em 0.25em; margin: 0em 0.25em; } input.raw_input:focus { box-shadow: none; } p.p-space { margin-bottom: 10px; } div.output_unrecognized { padding: 5px; font-weight: bold; color: red; } div.output_unrecognized a { color: inherit; text-decoration: none; } div.output_unrecognized a:hover { color: inherit; text-decoration: none; } .rendered_html { color: #000; /* any extras will just be numbers: */ } .rendered_html :link { text-decoration: underline; } .rendered_html :visited { text-decoration: underline; } .rendered_html h1:first-child { margin-top: 0.538em; } .rendered_html h2:first-child { margin-top: 0.636em; } .rendered_html h3:first-child { margin-top: 0.777em; } .rendered_html h4:first-child { margin-top: 1em; } .rendered_html h5:first-child { margin-top: 1em; } .rendered_html h6:first-child { margin-top: 1em; } .rendered_html ul:not(.list-inline), .rendered_html ol:not(.list-inline) { padding-left: 2em; } .rendered_html * + ul { margin-top: 1em; } .rendered_html * + ol { margin-top: 1em; } .rendered_html pre, .rendered_html tr, .rendered_html th, .rendered_html tbody tr:nth-child(odd) { background: #f5f5f5; } .rendered_html tbody tr:hover { background: rgba(66, 165, 245, 0.2); } .rendered_html * + table { margin-top: 1em; } .rendered_html * + p { margin-top: 1em; } .rendered_html * + img { margin-top: 1em; } .rendered_html img, .rendered_html img.unconfined, .rendered_html * + .alert { margin-top: 1em; } [dir=\"rtl\"] div.text_cell { /* Old browsers */ display: -webkit-box; -webkit-box-orient: horizontal; -webkit-box-align: stretch; display: -moz-box; -moz-box-orient: horizontal; -moz-box-align: stretch; display: box; box-orient: horizontal; box-align: stretch; /* Modern browsers */ display: flex; flex-direction: row; align-items: stretch; } @media (max-width: 540px) { div.text_cell > div.prompt { display: none; } } div.text_cell_render { /*font-family: \"Helvetica Neue\", Arial, Helvetica, Geneva, sans-serif;*/ outline: none; resize: none; width: inherit; border-style: none; padding: 0.5em 0.5em 0.5em 0.4em; color: #000; box-sizing: border-box; -moz-box-sizing: border-box; -webkit-box-sizing: border-box; } a.anchor-link:link { text-decoration: none; padding: 0px 20px; visibility: hidden; } h1:hover .anchor-link, h2:hover .anchor-link, h3:hover .anchor-link, h4:hover .anchor-link, h5:hover .anchor-link, h6:hover .anchor-link { visibility: visible; } .text_cell.rendered .input_area { display: none; } .text_cell.rendered .text_cell.rendered .rendered_html tr, .text_cell.rendered .rendered_html th, .text_cell.rendered .text_cell.unrendered .text_cell_render { display: none; } .text_cell .dropzone .input_area { border: 2px dashed #bababa; margin: -1px; } .cm-header-1, .cm-header-2, .cm-header-3, .cm-header-4, .cm-header-5, .cm-header-6 { font-weight: bold; font-family: \"Helvetica Neue\", Helvetica, Arial, sans-serif; } .cm-header-1 { font-size: 185.7%; } .cm-header-2 { font-size: 157.1%; } .cm-header-3 { font-size: 128.6%; } .cm-header-4 { font-size: 110%; } .cm-header-5 { font-size: 100%; font-style: italic; } .cm-header-6 { font-size: 100%; font-style: italic; } pre { line-height: 125%; margin: 0; } td.linenos pre { color: #000000; background-color: #f0f0f0; padding: 0 5px 0 5px; } span.linenos { color: #000000; background-color: #f0f0f0; padding: 0 5px 0 5px; } td.linenos pre.special { color: #000000; background-color: #ffffc0; padding: 0 5px 0 5px; } span.linenos.special { color: #000000; background-color: #ffffc0; padding: 0 5px 0 5px; } .highlight-ipynb .hll { background-color: #ffffcc } .highlight-ipynb { background: #f8f8f8; } .highlight-ipynb .c { color: #408080; font-style: italic } /* Comment */ .highlight-ipynb .err { border: 1px solid #FF0000 } /* Error */ .highlight-ipynb .k { color: #008000; font-weight: bold } /* Keyword */ .highlight-ipynb .o { color: #666666 } /* Operator */ .highlight-ipynb .ch { color: #408080; font-style: italic } /* Comment.Hashbang */ .highlight-ipynb .cm { color: #408080; font-style: italic } /* Comment.Multiline */ .highlight-ipynb .cp { color: #BC7A00 } /* Comment.Preproc */ .highlight-ipynb .cpf { color: #408080; font-style: italic } /* Comment.PreprocFile */ .highlight-ipynb .c1 { color: #408080; font-style: italic } /* Comment.Single */ .highlight-ipynb .cs { color: #408080; font-style: italic } /* Comment.Special */ .highlight-ipynb .gd { color: #A00000 } /* Generic.Deleted */ .highlight-ipynb .ge { font-style: italic } /* Generic.Emph */ .highlight-ipynb .gr { color: #FF0000 } /* Generic.Error */ .highlight-ipynb .gh { color: #000080; font-weight: bold } /* Generic.Heading */ .highlight-ipynb .gi { color: #00A000 } /* Generic.Inserted */ .highlight-ipynb .go { color: #888888 } /* Generic.Output */ .highlight-ipynb .gp { color: #000080; font-weight: bold } /* Generic.Prompt */ .highlight-ipynb .gs { font-weight: bold } /* Generic.Strong */ .highlight-ipynb .gu { color: #800080; font-weight: bold } /* Generic.Subheading */ .highlight-ipynb .gt { color: #0044DD } /* Generic.Traceback */ .highlight-ipynb .kc { color: #008000; font-weight: bold } /* Keyword.Constant */ .highlight-ipynb .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */ .highlight-ipynb .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */ .highlight-ipynb .kp { color: #008000 } /* Keyword.Pseudo */ .highlight-ipynb .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */ .highlight-ipynb .kt { color: #B00040 } /* Keyword.Type */ .highlight-ipynb .m { color: #666666 } /* Literal.Number */ .highlight-ipynb .s { color: #BA2121 } /* Literal.String */ .highlight-ipynb .na { color: #7D9029 } /* Name.Attribute */ .highlight-ipynb .nb { color: #008000 } /* Name.Builtin */ .highlight-ipynb .nc { color: #0000FF; font-weight: bold } /* Name.Class */ .highlight-ipynb .no { color: #880000 } /* Name.Constant */ .highlight-ipynb .nd { color: #AA22FF } /* Name.Decorator */ .highlight-ipynb .ni { color: #999999; font-weight: bold } /* Name.Entity */ .highlight-ipynb .ne { color: #D2413A; font-weight: bold } /* Name.Exception */ .highlight-ipynb .nf { color: #0000FF } /* Name.Function */ .highlight-ipynb .nl { color: #A0A000 } /* Name.Label */ .highlight-ipynb .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */ .highlight-ipynb .nt { color: #008000; font-weight: bold } /* Name.Tag */ .highlight-ipynb .nv { color: #19177C } /* Name.Variable */ .highlight-ipynb .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */ .highlight-ipynb .w { color: #bbbbbb } /* Text.Whitespace */ .highlight-ipynb .mb { color: #666666 } /* Literal.Number.Bin */ .highlight-ipynb .mf { color: #666666 } /* Literal.Number.Float */ .highlight-ipynb .mh { color: #666666 } /* Literal.Number.Hex */ .highlight-ipynb .mi { color: #666666 } /* Literal.Number.Integer */ .highlight-ipynb .mo { color: #666666 } /* Literal.Number.Oct */ .highlight-ipynb .sa { color: #BA2121 } /* Literal.String.Affix */ .highlight-ipynb .sb { color: #BA2121 } /* Literal.String.Backtick */ .highlight-ipynb .sc { color: #BA2121 } /* Literal.String.Char */ .highlight-ipynb .dl { color: #BA2121 } /* Literal.String.Delimiter */ .highlight-ipynb .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */ .highlight-ipynb .s2 { color: #BA2121 } /* Literal.String.Double */ .highlight-ipynb .se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */ .highlight-ipynb .sh { color: #BA2121 } /* Literal.String.Heredoc */ .highlight-ipynb .si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */ .highlight-ipynb .sx { color: #008000 } /* Literal.String.Other */ .highlight-ipynb .sr { color: #BB6688 } /* Literal.String.Regex */ .highlight-ipynb .s1 { color: #BA2121 } /* Literal.String.Single */ .highlight-ipynb .ss { color: #19177C } /* Literal.String.Symbol */ .highlight-ipynb .bp { color: #008000 } /* Name.Builtin.Pseudo */ .highlight-ipynb .fm { color: #0000FF } /* Name.Function.Magic */ .highlight-ipynb .vc { color: #19177C } /* Name.Variable.Class */ .highlight-ipynb .vg { color: #19177C } /* Name.Variable.Global */ .highlight-ipynb .vi { color: #19177C } /* Name.Variable.Instance */ .highlight-ipynb .vm { color: #19177C } /* Name.Variable.Magic */ .highlight-ipynb .il { color: #666666 } /* Literal.Number.Integer.Long */ .rendered_html a{text-decoration:inherit !important}.rendered_html :link{text-decoration:inherit !important}.rendered_html :visited{text-decoration:inherit !important}pre code{background-color:inherit !important}.highlight{color:#000000}.highlight code{color:#000000}.highlight .n{color:#333333}.highlight .p{color:#000000}.text_cell .prompt{display:none !important}div.input_prompt{padding:0.2em 0.4em}div.output_prompt{padding:0.4em}.text_cell{margin:0 !important;padding:0 !important;border:none !important}.text_cell_render{margin:0 !important;padding:0 !important;border:none !important}.rendered_html *+p{margin-top:inherit !important}.anchor-link{display:none !important}.code_cell{margin:0 !important;padding:5px 0 !important;border:none !important}.celltoolbar{border:thin solid #CFCFCF;border-bottom:none;background:#EEE;border-radius:2px 2px 0px 0px;width:100%;height:29px;padding-right:4px;box-orient:horizontal;box-align:stretch;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;-ms-flex-direction:row;flex-direction:row;-webkit-box-align:stretch;-ms-flex-align:stretch;align-items:stretch;box-pack:end;-webkit-box-pack:start;-ms-flex-pack:start;justify-content:flex-start;display:-webkit-flex}.celltoolbar .tags_button_container{display:-webkit-box;display:-ms-flexbox;display:flex}.celltoolbar .tags_button_container .tag-container{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;-ms-flex-direction:row;flex-direction:row;-webkit-box-flex:1;-ms-flex-positive:1;flex-grow:1;overflow:hidden;position:relative}.celltoolbar .tags_button_container .tag-container .cell-tag{background-color:#fff;white-space:nowrap;margin:3px 4px;padding:0 4px;border-radius:1px;border:1px solid #ccc;-webkit-box-shadow:none;box-shadow:none;width:inherit;font-size:13px;font-family:\"Helvetica Neue\", Helvetica, Arial, sans-serif;height:22px;line-height:22px;display:inline-block}div.input_area>div.highlight{margin:0.25em 0.4em !important}.code_cell pre{font-size:12px !important}.output_html table.dataframe{font-family:Arial, sans-serif;font-size:13px;line-height:20px}.output_html table.dataframe th,td{padding:4px;text-align:left}.bk-plot-wrapper tbody tr{background:none !important}.bk-plot-wrapper tbody tr:hover{background:none !important} /*# sourceMappingURL=jupyter-fixes.min.css.map */ MathJax.Hub.Config({ tex2jax: { inlineMath: [ ['$','$'], [\"\\\\(\",\"\\\\)\"] ], displayMath: [ ['$$','$$'], [\"\\\\[\",\"\\\\]\"] ], processEscapes: true, processEnvironments: true }, // Center justify equations in code and markdown cells. Elsewhere // we use CSS to left justify single line equations in code cells. displayAlign: 'center', \"HTML-CSS\": { styles: {'.MathJax_Display': {\"margin\": 0}}, linebreaks: { automatic: true } } }); rio-tiler.mosaic \u00b6 In This notebook you'll learn how to: use create mercator tiles from multiple observations (assets) using rio_tiler.mosaic submodule create custom pixel_selection methods look for sentinel-2-cogs data create custom tiler using `STACReade`` In [1]: % pylab inline Populating the interactive namespace from numpy and matplotlib Requirements \u00b6 To be able to run this notebook you'll need the following requirements: rasterio ipyleaflet rio-tiler~= 2.0b In [ ]: ! pip install rio - tiler ipyleaflet -- pre rio - tiler In [2]: import json import requests import mercantile from rio_tiler.io import COGReader , STACReader from rio_tiler.mosaic import mosaic_reader from rio_tiler.mosaic.methods import defaults from rio_tiler.mosaic.methods.base import MosaicMethodBase from rio_tiler.utils import linear_rescale from rio_tiler.colormap import get_colormap from rio_tiler.profiles import img_profiles from rasterio.plot import reshape_as_image from rasterio.features import bounds as featureBounds from ipyleaflet import Map , basemaps , TileLayer , basemap_to_tiles , GeoJSON Data \u00b6 For this demo we will use the Sentinel-2 data stored as COGs on AWS. Sentinel 2 COGs \u00b6 Thanks to Digital Earth Africa and in collaboration with Sinergise, Element 84, Amazon Web Services (AWS) and the Committee on Earth Observation Satellites (CEOS), Sentinel 2 (Level 2) data over Africa, usually stored as JPEG2000, has been translated to COG more important a STAC database and API has been setup. https://www.digitalearthafrica.org/news/operational-and-ready-use-satellite-data-now-available-across-africa The API is provided by @element84 and follows the latest specification: https://earth-search.aws.element84.com/v0 In [3]: stac_endpoint = \"https://earth-search.aws.element84.com/v0/search\" Search for data \u00b6 Define Area of Interest (AOI) \u00b6 In [4]: # use geojson.io geojson = { \"type\" : \"FeatureCollection\" , \"features\" : [ { \"type\" : \"Feature\" , \"properties\" : {}, \"geometry\" : { \"type\" : \"Polygon\" , \"coordinates\" : [ [ [ 30.810813903808594 , 29.454247067148533 ], [ 30.88600158691406 , 29.454247067148533 ], [ 30.88600158691406 , 29.51879923863822 ], [ 30.810813903808594 , 29.51879923863822 ], [ 30.810813903808594 , 29.454247067148533 ] ] ] } } ] } bounds = featureBounds ( geojson ) STAC Search \u00b6 Use STAC API to search for data over our AOI Doc: https://github.com/radiantearth/stac-api-spec In [5]: # Date filter date_min = \"2019-06-01\" date_max = \"2019-09-01\" start = datetime . datetime . strptime ( date_min , \"%Y-%m- %d \" ) . strftime ( \"%Y-%m- %d T00:00:00Z\" ) end = datetime . datetime . strptime ( date_max , \"%Y-%m- %d \" ) . strftime ( \"%Y-%m- %d T23:59:59Z\" ) query = { \"collections\" : [ \"sentinel-s2-l2a-cogs\" ], # Make sure to query only sentinel-2 COGs collection \"datetime\" : f \" { start } / { end } \" , \"query\" : { \"eo:cloud_cover\" : { \"lt\" : 5 } # Use low cloud cover }, \"intersects\" : geojson [ \"features\" ][ 0 ][ \"geometry\" ], \"limit\" : 1000 , \"fields\" : { 'include' : [ 'id' , 'properties.datetime' , 'properties.eo:cloud_cover' ], # Make returned response ligth 'exclude' : [ 'links' ] } } headers = { \"Content-Type\" : \"application/json\" , \"Accept-Encoding\" : \"gzip\" , \"Accept\" : \"application/geo+json\" , } data = requests . post ( stac_endpoint , headers = headers , json = query ) . json () print ( data [ \"context\" ]) print () print ( \"Example:\" ) print ( json . dumps ( data [ \"features\" ][ 0 ], indent = 4 )) sceneid = [ f [ \"id\" ] for f in data [ \"features\" ]] cloudcover = [ f [ \"properties\" ][ \"eo:cloud_cover\" ] for f in data [ \"features\" ]] dates = [ f [ \"properties\" ][ \"datetime\" ][ 0 : 10 ] for f in data [ \"features\" ]] # For this demo we will use the True color image `TCI` asset assets = [ f [ \"assets\" ][ \"visual\" ][ \"href\" ] for f in data [ \"features\" ]] {'page': 1, 'limit': 1000, 'matched': 21, 'returned': 21} Example: { \"assets\": { \"overview\": { \"proj:shape\": [ 343, 343 ], \"proj:transform\": [ 320, 0, 199980, 0, -320, 3300000, 0, 0, 1 ], \"href\": \"https://sentinel-cogs.s3.us-west-2.amazonaws.com/sentinel-s2-l2a-cogs/2019/S2B_36RTT_20190830_0_L2A/L2A_PVI.tif\", \"title\": \"True color image\", \"type\": \"image/tiff; application=geotiff; profile=cloud-optimized\" }, \"thumbnail\": { \"href\": \"https://roda.sentinel-hub.com/sentinel-s2-l1c/tiles/36/R/TT/2019/8/30/0/preview.jpg\", \"title\": \"Thumbnail\", \"type\": \"image/png\" }, \"metadata\": { \"href\": \"https://roda.sentinel-hub.com/sentinel-s2-l2a/tiles/36/R/TT/2019/8/30/0/metadata.xml\", \"title\": \"Original XML metadata\", \"type\": \"application/xml\" }, \"B11\": { \"proj:shape\": [ 5490, 5490 ], \"proj:transform\": [ 20, 0, 199980, 0, -20, 3300000, 0, 0, 1 ], \"href\": \"https://sentinel-cogs.s3.us-west-2.amazonaws.com/sentinel-s2-l2a-cogs/2019/S2B_36RTT_20190830_0_L2A/B11.tif\", \"title\": \"Band 11 (swir16)\", \"type\": \"image/tiff; application=geotiff; profile=cloud-optimized\" }, \"B01\": { \"proj:shape\": [ 1830, 1830 ], \"proj:transform\": [ 60, 0, 199980, 0, -60, 3300000, 0, 0, 1 ], \"href\": \"https://sentinel-cogs.s3.us-west-2.amazonaws.com/sentinel-s2-l2a-cogs/2019/S2B_36RTT_20190830_0_L2A/B01.tif\", \"title\": \"Band 1 (coastal)\", \"type\": \"image/tiff; application=geotiff; profile=cloud-optimized\" }, \"B12\": { \"proj:shape\": [ 5490, 5490 ], \"proj:transform\": [ 20, 0, 199980, 0, -20, 3300000, 0, 0, 1 ], \"href\": \"https://sentinel-cogs.s3.us-west-2.amazonaws.com/sentinel-s2-l2a-cogs/2019/S2B_36RTT_20190830_0_L2A/B12.tif\", \"title\": \"Band 12 (swir22)\", \"type\": \"image/tiff; application=geotiff; profile=cloud-optimized\" }, \"B02\": { \"proj:shape\": [ 10980, 10980 ], \"proj:transform\": [ 10, 0, 199980, 0, -10, 3300000, 0, 0, 1 ], \"href\": \"https://sentinel-cogs.s3.us-west-2.amazonaws.com/sentinel-s2-l2a-cogs/2019/S2B_36RTT_20190830_0_L2A/B02.tif\", \"title\": \"Band 2 (blue)\", \"type\": \"image/tiff; application=geotiff; profile=cloud-optimized\" }, \"B03\": { \"proj:shape\": [ 10980, 10980 ], \"proj:transform\": [ 10, 0, 199980, 0, -10, 3300000, 0, 0, 1 ], \"href\": \"https://sentinel-cogs.s3.us-west-2.amazonaws.com/sentinel-s2-l2a-cogs/2019/S2B_36RTT_20190830_0_L2A/B03.tif\", \"title\": \"Band 3 (green)\", \"type\": \"image/tiff; application=geotiff; profile=cloud-optimized\" }, \"B04\": { \"proj:shape\": [ 10980, 10980 ], \"proj:transform\": [ 10, 0, 199980, 0, -10, 3300000, 0, 0, 1 ], \"href\": \"https://sentinel-cogs.s3.us-west-2.amazonaws.com/sentinel-s2-l2a-cogs/2019/S2B_36RTT_20190830_0_L2A/B04.tif\", \"title\": \"Band 4 (red)\", \"type\": \"image/tiff; application=geotiff; profile=cloud-optimized\" }, \"AOT\": { \"proj:shape\": [ 1830, 1830 ], \"proj:transform\": [ 60, 0, 199980, 0, -60, 3300000, 0, 0, 1 ], \"href\": \"https://sentinel-cogs.s3.us-west-2.amazonaws.com/sentinel-s2-l2a-cogs/2019/S2B_36RTT_20190830_0_L2A/AOT.tif\", \"title\": \"Aerosol Optical Thickness (AOT)\", \"type\": \"image/tiff; application=geotiff; profile=cloud-optimized\" }, \"B05\": { \"proj:shape\": [ 5490, 5490 ], \"proj:transform\": [ 20, 0, 199980, 0, -20, 3300000, 0, 0, 1 ], \"href\": \"https://sentinel-cogs.s3.us-west-2.amazonaws.com/sentinel-s2-l2a-cogs/2019/S2B_36RTT_20190830_0_L2A/B05.tif\", \"title\": \"Band 5\", \"type\": \"image/tiff; application=geotiff; profile=cloud-optimized\" }, \"B06\": { \"proj:shape\": [ 5490, 5490 ], \"proj:transform\": [ 20, 0, 199980, 0, -20, 3300000, 0, 0, 1 ], \"href\": \"https://sentinel-cogs.s3.us-west-2.amazonaws.com/sentinel-s2-l2a-cogs/2019/S2B_36RTT_20190830_0_L2A/B06.tif\", \"title\": \"Band 6\", \"type\": \"image/tiff; application=geotiff; profile=cloud-optimized\" }, \"B07\": { \"proj:shape\": [ 5490, 5490 ], \"proj:transform\": [ 20, 0, 199980, 0, -20, 3300000, 0, 0, 1 ], \"href\": \"https://sentinel-cogs.s3.us-west-2.amazonaws.com/sentinel-s2-l2a-cogs/2019/S2B_36RTT_20190830_0_L2A/B07.tif\", \"title\": \"Band 7\", \"type\": \"image/tiff; application=geotiff; profile=cloud-optimized\" }, \"B08\": { \"proj:shape\": [ 10980, 10980 ], \"proj:transform\": [ 10, 0, 199980, 0, -10, 3300000, 0, 0, 1 ], \"href\": \"https://sentinel-cogs.s3.us-west-2.amazonaws.com/sentinel-s2-l2a-cogs/2019/S2B_36RTT_20190830_0_L2A/B08.tif\", \"title\": \"Band 8 (nir)\", \"type\": \"image/tiff; application=geotiff; profile=cloud-optimized\" }, \"B8A\": { \"proj:shape\": [ 5490, 5490 ], \"proj:transform\": [ 20, 0, 199980, 0, -20, 3300000, 0, 0, 1 ], \"href\": \"https://sentinel-cogs.s3.us-west-2.amazonaws.com/sentinel-s2-l2a-cogs/2019/S2B_36RTT_20190830_0_L2A/B8A.tif\", \"title\": \"Band 8A\", \"type\": \"image/tiff; application=geotiff; profile=cloud-optimized\" }, \"B09\": { \"proj:shape\": [ 1830, 1830 ], \"proj:transform\": [ 60, 0, 199980, 0, -60, 3300000, 0, 0, 1 ], \"href\": \"https://sentinel-cogs.s3.us-west-2.amazonaws.com/sentinel-s2-l2a-cogs/2019/S2B_36RTT_20190830_0_L2A/B09.tif\", \"title\": \"Band 9\", \"type\": \"image/tiff; application=geotiff; profile=cloud-optimized\" }, \"WVP\": { \"proj:shape\": [ 10980, 10980 ], \"proj:transform\": [ 10, 0, 199980, 0, -10, 3300000, 0, 0, 1 ], \"href\": \"https://sentinel-cogs.s3.us-west-2.amazonaws.com/sentinel-s2-l2a-cogs/2019/S2B_36RTT_20190830_0_L2A/WVP.tif\", \"title\": \"Water Vapour (WVP)\", \"type\": \"image/tiff; application=geotiff; profile=cloud-optimized\" }, \"visual\": { \"proj:shape\": [ 10980, 10980 ], \"proj:transform\": [ 10, 0, 199980, 0, -10, 3300000, 0, 0, 1 ], \"href\": \"https://sentinel-cogs.s3.us-west-2.amazonaws.com/sentinel-s2-l2a-cogs/2019/S2B_36RTT_20190830_0_L2A/TCI.tif\", \"title\": \"True color image\", \"type\": \"image/tiff; application=geotiff; profile=cloud-optimized\" }, \"SCL\": { \"proj:shape\": [ 5490, 5490 ], \"proj:transform\": [ 20, 0, 199980, 0, -20, 3300000, 0, 0, 1 ], \"href\": \"https://sentinel-cogs.s3.us-west-2.amazonaws.com/sentinel-s2-l2a-cogs/2019/S2B_36RTT_20190830_0_L2A/SCL.tif\", \"title\": \"Scene Classification Map (SCL)\", \"type\": \"image/tiff; application=geotiff; profile=cloud-optimized\" }, \"info\": { \"href\": \"https://roda.sentinel-hub.com/sentinel-s2-l2a/tiles/36/R/TT/2019/8/30/0/tileInfo.json\", \"title\": \"Original JSON metadata\", \"type\": \"application/json\" } }, \"bbox\": [ 29.896473859714554, 28.804454491507947, 31.003792553495717, 29.81537540150385 ], \"geometry\": { \"coordinates\": [ [ [ 29.92628490999458, 28.804454491507947 ], [ 29.896473859714554, 29.793998377705638 ], [ 31.003792553495717, 29.81537540150385 ], [ 30.721048631911938, 28.8202241961706 ], [ 29.92628490999458, 28.804454491507947 ] ] ], \"type\": \"Polygon\" }, \"id\": \"S2B_36RTT_20190830_0_L2A\", \"collection\": \"sentinel-s2-l2a-cogs\", \"type\": \"Feature\", \"properties\": { \"datetime\": \"2019-08-30T08:52:09Z\", \"eo:cloud_cover\": 1.96 } } In [6]: m = Map ( basemap = basemaps . OpenStreetMap . Mapnik , center = (( bounds [ 1 ] + bounds [ 3 ]) / 2 ,( bounds [ 0 ] + bounds [ 2 ]) / 2 ), zoom = 8 ) geo_json = GeoJSON ( data = data , style = { 'opacity' : 1 , 'dashArray' : '1' , 'fillOpacity' : 0 , 'weight' : 1 }, ) m . add_layer ( geo_json ) m var element = $('#0c2ede63-0ff2-4a21-8c0d-6720a33d63ab'); {\"version_major\": 2, \"version_minor\": 0, \"model_id\": \"98124e5cc52c4795b164a228bc2ce4ca\"} Define the tiler \u00b6 In [7]: def tiler ( asset , * args , ** kwargs ): with COGReader ( asset ) as cog : return cog . tile ( * args , ** kwargs ) In [8]: # List of z12 mercatile tile tiles = list ( mercantile . tiles ( * bounds , 12 )) FirstMethod: Fill with the first value avialable \u00b6 In [9]: tile = tiles [ 0 ] ( tile , mask ), assets_used = mosaic_reader ( assets , tiler , tile . x , tile . y , tile . z , threads = 1 , chunk_size = 2 , ) fig = figure ( figsize = ( 30 , 10 )) ax = fig . add_subplot ( 1 , 2 , 1 ) ax . imshow ( reshape_as_image ( tile )) ax = fig . add_subplot ( 1 , 2 , 2 ) ax . imshow ( mask ) Out[9]: <matplotlib.image.AxesImage at 0x118e2a250> *{stroke-linecap:butt;stroke-linejoin:round;} In [10]: print ( assets_used ) ['https://sentinel-cogs.s3.us-west-2.amazonaws.com/sentinel-s2-l2a-cogs/2019/S2B_36RTT_20190830_0_L2A/TCI.tif'] MeanMethod: Get the mean from all the stack of data \u00b6 In [11]: tile = tiles [ 0 ] ( tile , mask ), assets_used = mosaic_reader ( assets , tiler , tile . x , tile . y , tile . z , pixel_selection = defaults . MeanMethod (), ) fig = figure ( figsize = ( 30 , 10 )) ax = fig . add_subplot ( 1 , 2 , 1 ) ax . imshow ( reshape_as_image ( tile )) ax = fig . add_subplot ( 1 , 2 , 2 ) ax . imshow ( mask ) Out[11]: <matplotlib.image.AxesImage at 0x119342250> *{stroke-linecap:butt;stroke-linejoin:round;} In [12]: print ( assets_used ) ['https://sentinel-cogs.s3.us-west-2.amazonaws.com/sentinel-s2-l2a-cogs/2019/S2B_36RTT_20190830_0_L2A/TCI.tif', 'https://sentinel-cogs.s3.us-west-2.amazonaws.com/sentinel-s2-l2a-cogs/2019/S2A_36RTT_20190825_0_L2A/TCI.tif', 'https://sentinel-cogs.s3.us-west-2.amazonaws.com/sentinel-s2-l2a-cogs/2019/S2B_36RTT_20190820_0_L2A/TCI.tif', 'https://sentinel-cogs.s3.us-west-2.amazonaws.com/sentinel-s2-l2a-cogs/2019/S2A_36RTT_20190815_0_L2A/TCI.tif', 'https://sentinel-cogs.s3.us-west-2.amazonaws.com/sentinel-s2-l2a-cogs/2019/S2B_36RTT_20190810_0_L2A/TCI.tif', 'https://sentinel-cogs.s3.us-west-2.amazonaws.com/sentinel-s2-l2a-cogs/2019/S2A_36RTT_20190805_0_L2A/TCI.tif', 'https://sentinel-cogs.s3.us-west-2.amazonaws.com/sentinel-s2-l2a-cogs/2019/S2A_36RTT_20190726_0_L2A/TCI.tif', 'https://sentinel-cogs.s3.us-west-2.amazonaws.com/sentinel-s2-l2a-cogs/2019/S2B_36RTT_20190721_0_L2A/TCI.tif', 'https://sentinel-cogs.s3.us-west-2.amazonaws.com/sentinel-s2-l2a-cogs/2019/S2B_36RTT_20190718_0_L2A/TCI.tif', 'https://sentinel-cogs.s3.us-west-2.amazonaws.com/sentinel-s2-l2a-cogs/2019/S2A_36RTT_20190716_0_L2A/TCI.tif', 'https://sentinel-cogs.s3.us-west-2.amazonaws.com/sentinel-s2-l2a-cogs/2019/S2B_36RTT_20190711_0_L2A/TCI.tif', 'https://sentinel-cogs.s3.us-west-2.amazonaws.com/sentinel-s2-l2a-cogs/2019/S2A_36RTT_20190706_0_L2A/TCI.tif', 'https://sentinel-cogs.s3.us-west-2.amazonaws.com/sentinel-s2-l2a-cogs/2019/S2B_36RTT_20190701_0_L2A/TCI.tif', 'https://sentinel-cogs.s3.us-west-2.amazonaws.com/sentinel-s2-l2a-cogs/2019/S2A_36RTT_20190626_0_L2A/TCI.tif', 'https://sentinel-cogs.s3.us-west-2.amazonaws.com/sentinel-s2-l2a-cogs/2019/S2B_36RTT_20190621_0_L2A/TCI.tif', 'https://sentinel-cogs.s3.us-west-2.amazonaws.com/sentinel-s2-l2a-cogs/2019/S2B_36RTT_20190618_0_L2A/TCI.tif', 'https://sentinel-cogs.s3.us-west-2.amazonaws.com/sentinel-s2-l2a-cogs/2019/S2A_36RTT_20190616_1_L2A/TCI.tif', 'https://sentinel-cogs.s3.us-west-2.amazonaws.com/sentinel-s2-l2a-cogs/2019/S2B_36RTT_20190611_0_L2A/TCI.tif', 'https://sentinel-cogs.s3.us-west-2.amazonaws.com/sentinel-s2-l2a-cogs/2019/S2A_36RTT_20190606_0_L2A/TCI.tif', 'https://sentinel-cogs.s3.us-west-2.amazonaws.com/sentinel-s2-l2a-cogs/2019/S2A_36RTT_20190603_0_L2A/TCI.tif', 'https://sentinel-cogs.s3.us-west-2.amazonaws.com/sentinel-s2-l2a-cogs/2019/S2B_36RTT_20190601_0_L2A/TCI.tif'] Create Custom pixel_selection class \u00b6 1. Using a 4th band for decision: highest NDVI \u00b6 In [14]: stac_item = \"https://earth-search.aws.element84.com/v0/collections/sentinel-s2-l2a-cogs/items/ {sceneid} \" stac_assets = [ stac_item . format ( sceneid = scene ) for scene in sceneid ] In [15]: # Fisrt, let's checkout the STDEV of the NDVI values # Because we need to use multiple STAC assets, it's easier to use the STACReader def custom_tiler ( asset , * args , ** kwargs ): with STACReader ( asset ) as stac : return stac . tile ( * args , expression = \"(B08-B04)/(B08+B04)\" ) tile = tiles [ 0 ] ( tile , mask ), assets_used = mosaic_reader ( stac_assets , custom_tiler , tile . x , tile . y , tile . z , pixel_selection = defaults . StdevMethod (), threads = 1 , chunk_size = 2 , ) fig = figure ( figsize = ( 30 , 10 )) ax = fig . add_subplot ( 1 , 2 , 1 ) ax . imshow ( tile [ 0 ]) ax = fig . add_subplot ( 1 , 2 , 2 ) ax . imshow ( mask ) In [51]: # We create a custom tiler function that will read the TCI asset and add a 4th representing the NDVI def custom_tiler ( asset , * args , ** kwargs ): with STACReader ( asset ) as stac : tile , mask = stac . tile ( * args , assets = \"visual\" ) ndvi , _ = stac . tile ( * args , expression = \"(B08-B04)/(B08+B04)\" ) return numpy . concatenate (( tile , ndvi )), mask In [37]: class CustomFourthBandH ( MosaicMethodBase ): \"\"\"Feed the mosaic tile with the Mean pixel value.\"\"\" @property def data ( self ): \"\"\"Return data and mask.\"\"\" if self . tile is not None : return self . tile . data [: - 1 ], ~ self . tile . mask [ 0 ] * 255 else : return None , None def feed ( self , tile ): \"\"\"Add data to tile.\"\"\" if self . tile is None : self . tile = tile return pidex = ( numpy . bitwise_and ( tile . data [ - 1 ] > self . tile . data [ - 1 ], ~ tile . mask ) | self . tile . mask ) mask = numpy . where ( pidex , tile . mask , self . tile . mask ) self . tile = numpy . ma . where ( pidex , tile , self . tile ) self . tile . mask = mask In [57]: tile = tiles [ 0 ] ( tile , mask ), assets_used = mosaic_reader ( stac_assets [ 0 : 10 ], custom_tiler , tile . x , tile . y , tile . z , pixel_selection = CustomFourthBandH (), threads = 1 , chunk_size = 2 , ) fig = figure ( figsize = ( 30 , 10 )) ax = fig . add_subplot ( 1 , 2 , 1 ) # NOTE: because we are using NDVI + Visual, the output array, will be in float32 ax . imshow ( reshape_as_image ( tile . astype ( \"uint8\" ))) ax = fig . add_subplot ( 1 , 2 , 2 ) ax . imshow ( mask ) Out[57]: <matplotlib.image.AxesImage at 0x11c3efd10> In [ ]:","title":"Mosaic"},{"location":"examples/Using-rio-tiler-mosaic/#rio-tilermosaic","text":"In This notebook you'll learn how to: use create mercator tiles from multiple observations (assets) using rio_tiler.mosaic submodule create custom pixel_selection methods look for sentinel-2-cogs data create custom tiler using `STACReade`` In [1]: % pylab inline Populating the interactive namespace from numpy and matplotlib","title":"rio-tiler.mosaic"},{"location":"examples/Using-rio-tiler-mosaic/#requirements","text":"To be able to run this notebook you'll need the following requirements: rasterio ipyleaflet rio-tiler~= 2.0b In [ ]: ! pip install rio - tiler ipyleaflet -- pre rio - tiler In [2]: import json import requests import mercantile from rio_tiler.io import COGReader , STACReader from rio_tiler.mosaic import mosaic_reader from rio_tiler.mosaic.methods import defaults from rio_tiler.mosaic.methods.base import MosaicMethodBase from rio_tiler.utils import linear_rescale from rio_tiler.colormap import get_colormap from rio_tiler.profiles import img_profiles from rasterio.plot import reshape_as_image from rasterio.features import bounds as featureBounds from ipyleaflet import Map , basemaps , TileLayer , basemap_to_tiles , GeoJSON","title":"Requirements"},{"location":"examples/Using-rio-tiler-mosaic/#data","text":"For this demo we will use the Sentinel-2 data stored as COGs on AWS.","title":"Data"},{"location":"examples/Using-rio-tiler-mosaic/#sentinel-2-cogs","text":"Thanks to Digital Earth Africa and in collaboration with Sinergise, Element 84, Amazon Web Services (AWS) and the Committee on Earth Observation Satellites (CEOS), Sentinel 2 (Level 2) data over Africa, usually stored as JPEG2000, has been translated to COG more important a STAC database and API has been setup. https://www.digitalearthafrica.org/news/operational-and-ready-use-satellite-data-now-available-across-africa The API is provided by @element84 and follows the latest specification: https://earth-search.aws.element84.com/v0 In [3]: stac_endpoint = \"https://earth-search.aws.element84.com/v0/search\"","title":"Sentinel 2 COGs"},{"location":"examples/Using-rio-tiler-mosaic/#search-for-data","text":"","title":"Search for data"},{"location":"examples/Using-rio-tiler-mosaic/#define-area-of-interest-aoi","text":"In [4]: # use geojson.io geojson = { \"type\" : \"FeatureCollection\" , \"features\" : [ { \"type\" : \"Feature\" , \"properties\" : {}, \"geometry\" : { \"type\" : \"Polygon\" , \"coordinates\" : [ [ [ 30.810813903808594 , 29.454247067148533 ], [ 30.88600158691406 , 29.454247067148533 ], [ 30.88600158691406 , 29.51879923863822 ], [ 30.810813903808594 , 29.51879923863822 ], [ 30.810813903808594 , 29.454247067148533 ] ] ] } } ] } bounds = featureBounds ( geojson )","title":"Define Area of Interest (AOI)"},{"location":"examples/Using-rio-tiler-mosaic/#stac-search","text":"Use STAC API to search for data over our AOI Doc: https://github.com/radiantearth/stac-api-spec In [5]: # Date filter date_min = \"2019-06-01\" date_max = \"2019-09-01\" start = datetime . datetime . strptime ( date_min , \"%Y-%m- %d \" ) . strftime ( \"%Y-%m- %d T00:00:00Z\" ) end = datetime . datetime . strptime ( date_max , \"%Y-%m- %d \" ) . strftime ( \"%Y-%m- %d T23:59:59Z\" ) query = { \"collections\" : [ \"sentinel-s2-l2a-cogs\" ], # Make sure to query only sentinel-2 COGs collection \"datetime\" : f \" { start } / { end } \" , \"query\" : { \"eo:cloud_cover\" : { \"lt\" : 5 } # Use low cloud cover }, \"intersects\" : geojson [ \"features\" ][ 0 ][ \"geometry\" ], \"limit\" : 1000 , \"fields\" : { 'include' : [ 'id' , 'properties.datetime' , 'properties.eo:cloud_cover' ], # Make returned response ligth 'exclude' : [ 'links' ] } } headers = { \"Content-Type\" : \"application/json\" , \"Accept-Encoding\" : \"gzip\" , \"Accept\" : \"application/geo+json\" , } data = requests . post ( stac_endpoint , headers = headers , json = query ) . json () print ( data [ \"context\" ]) print () print ( \"Example:\" ) print ( json . dumps ( data [ \"features\" ][ 0 ], indent = 4 )) sceneid = [ f [ \"id\" ] for f in data [ \"features\" ]] cloudcover = [ f [ \"properties\" ][ \"eo:cloud_cover\" ] for f in data [ \"features\" ]] dates = [ f [ \"properties\" ][ \"datetime\" ][ 0 : 10 ] for f in data [ \"features\" ]] # For this demo we will use the True color image `TCI` asset assets = [ f [ \"assets\" ][ \"visual\" ][ \"href\" ] for f in data [ \"features\" ]] {'page': 1, 'limit': 1000, 'matched': 21, 'returned': 21} Example: { \"assets\": { \"overview\": { \"proj:shape\": [ 343, 343 ], \"proj:transform\": [ 320, 0, 199980, 0, -320, 3300000, 0, 0, 1 ], \"href\": \"https://sentinel-cogs.s3.us-west-2.amazonaws.com/sentinel-s2-l2a-cogs/2019/S2B_36RTT_20190830_0_L2A/L2A_PVI.tif\", \"title\": \"True color image\", \"type\": \"image/tiff; application=geotiff; profile=cloud-optimized\" }, \"thumbnail\": { \"href\": \"https://roda.sentinel-hub.com/sentinel-s2-l1c/tiles/36/R/TT/2019/8/30/0/preview.jpg\", \"title\": \"Thumbnail\", \"type\": \"image/png\" }, \"metadata\": { \"href\": \"https://roda.sentinel-hub.com/sentinel-s2-l2a/tiles/36/R/TT/2019/8/30/0/metadata.xml\", \"title\": \"Original XML metadata\", \"type\": \"application/xml\" }, \"B11\": { \"proj:shape\": [ 5490, 5490 ], \"proj:transform\": [ 20, 0, 199980, 0, -20, 3300000, 0, 0, 1 ], \"href\": \"https://sentinel-cogs.s3.us-west-2.amazonaws.com/sentinel-s2-l2a-cogs/2019/S2B_36RTT_20190830_0_L2A/B11.tif\", \"title\": \"Band 11 (swir16)\", \"type\": \"image/tiff; application=geotiff; profile=cloud-optimized\" }, \"B01\": { \"proj:shape\": [ 1830, 1830 ], \"proj:transform\": [ 60, 0, 199980, 0, -60, 3300000, 0, 0, 1 ], \"href\": \"https://sentinel-cogs.s3.us-west-2.amazonaws.com/sentinel-s2-l2a-cogs/2019/S2B_36RTT_20190830_0_L2A/B01.tif\", \"title\": \"Band 1 (coastal)\", \"type\": \"image/tiff; application=geotiff; profile=cloud-optimized\" }, \"B12\": { \"proj:shape\": [ 5490, 5490 ], \"proj:transform\": [ 20, 0, 199980, 0, -20, 3300000, 0, 0, 1 ], \"href\": \"https://sentinel-cogs.s3.us-west-2.amazonaws.com/sentinel-s2-l2a-cogs/2019/S2B_36RTT_20190830_0_L2A/B12.tif\", \"title\": \"Band 12 (swir22)\", \"type\": \"image/tiff; application=geotiff; profile=cloud-optimized\" }, \"B02\": { \"proj:shape\": [ 10980, 10980 ], \"proj:transform\": [ 10, 0, 199980, 0, -10, 3300000, 0, 0, 1 ], \"href\": \"https://sentinel-cogs.s3.us-west-2.amazonaws.com/sentinel-s2-l2a-cogs/2019/S2B_36RTT_20190830_0_L2A/B02.tif\", \"title\": \"Band 2 (blue)\", \"type\": \"image/tiff; application=geotiff; profile=cloud-optimized\" }, \"B03\": { \"proj:shape\": [ 10980, 10980 ], \"proj:transform\": [ 10, 0, 199980, 0, -10, 3300000, 0, 0, 1 ], \"href\": \"https://sentinel-cogs.s3.us-west-2.amazonaws.com/sentinel-s2-l2a-cogs/2019/S2B_36RTT_20190830_0_L2A/B03.tif\", \"title\": \"Band 3 (green)\", \"type\": \"image/tiff; application=geotiff; profile=cloud-optimized\" }, \"B04\": { \"proj:shape\": [ 10980, 10980 ], \"proj:transform\": [ 10, 0, 199980, 0, -10, 3300000, 0, 0, 1 ], \"href\": \"https://sentinel-cogs.s3.us-west-2.amazonaws.com/sentinel-s2-l2a-cogs/2019/S2B_36RTT_20190830_0_L2A/B04.tif\", \"title\": \"Band 4 (red)\", \"type\": \"image/tiff; application=geotiff; profile=cloud-optimized\" }, \"AOT\": { \"proj:shape\": [ 1830, 1830 ], \"proj:transform\": [ 60, 0, 199980, 0, -60, 3300000, 0, 0, 1 ], \"href\": \"https://sentinel-cogs.s3.us-west-2.amazonaws.com/sentinel-s2-l2a-cogs/2019/S2B_36RTT_20190830_0_L2A/AOT.tif\", \"title\": \"Aerosol Optical Thickness (AOT)\", \"type\": \"image/tiff; application=geotiff; profile=cloud-optimized\" }, \"B05\": { \"proj:shape\": [ 5490, 5490 ], \"proj:transform\": [ 20, 0, 199980, 0, -20, 3300000, 0, 0, 1 ], \"href\": \"https://sentinel-cogs.s3.us-west-2.amazonaws.com/sentinel-s2-l2a-cogs/2019/S2B_36RTT_20190830_0_L2A/B05.tif\", \"title\": \"Band 5\", \"type\": \"image/tiff; application=geotiff; profile=cloud-optimized\" }, \"B06\": { \"proj:shape\": [ 5490, 5490 ], \"proj:transform\": [ 20, 0, 199980, 0, -20, 3300000, 0, 0, 1 ], \"href\": \"https://sentinel-cogs.s3.us-west-2.amazonaws.com/sentinel-s2-l2a-cogs/2019/S2B_36RTT_20190830_0_L2A/B06.tif\", \"title\": \"Band 6\", \"type\": \"image/tiff; application=geotiff; profile=cloud-optimized\" }, \"B07\": { \"proj:shape\": [ 5490, 5490 ], \"proj:transform\": [ 20, 0, 199980, 0, -20, 3300000, 0, 0, 1 ], \"href\": \"https://sentinel-cogs.s3.us-west-2.amazonaws.com/sentinel-s2-l2a-cogs/2019/S2B_36RTT_20190830_0_L2A/B07.tif\", \"title\": \"Band 7\", \"type\": \"image/tiff; application=geotiff; profile=cloud-optimized\" }, \"B08\": { \"proj:shape\": [ 10980, 10980 ], \"proj:transform\": [ 10, 0, 199980, 0, -10, 3300000, 0, 0, 1 ], \"href\": \"https://sentinel-cogs.s3.us-west-2.amazonaws.com/sentinel-s2-l2a-cogs/2019/S2B_36RTT_20190830_0_L2A/B08.tif\", \"title\": \"Band 8 (nir)\", \"type\": \"image/tiff; application=geotiff; profile=cloud-optimized\" }, \"B8A\": { \"proj:shape\": [ 5490, 5490 ], \"proj:transform\": [ 20, 0, 199980, 0, -20, 3300000, 0, 0, 1 ], \"href\": \"https://sentinel-cogs.s3.us-west-2.amazonaws.com/sentinel-s2-l2a-cogs/2019/S2B_36RTT_20190830_0_L2A/B8A.tif\", \"title\": \"Band 8A\", \"type\": \"image/tiff; application=geotiff; profile=cloud-optimized\" }, \"B09\": { \"proj:shape\": [ 1830, 1830 ], \"proj:transform\": [ 60, 0, 199980, 0, -60, 3300000, 0, 0, 1 ], \"href\": \"https://sentinel-cogs.s3.us-west-2.amazonaws.com/sentinel-s2-l2a-cogs/2019/S2B_36RTT_20190830_0_L2A/B09.tif\", \"title\": \"Band 9\", \"type\": \"image/tiff; application=geotiff; profile=cloud-optimized\" }, \"WVP\": { \"proj:shape\": [ 10980, 10980 ], \"proj:transform\": [ 10, 0, 199980, 0, -10, 3300000, 0, 0, 1 ], \"href\": \"https://sentinel-cogs.s3.us-west-2.amazonaws.com/sentinel-s2-l2a-cogs/2019/S2B_36RTT_20190830_0_L2A/WVP.tif\", \"title\": \"Water Vapour (WVP)\", \"type\": \"image/tiff; application=geotiff; profile=cloud-optimized\" }, \"visual\": { \"proj:shape\": [ 10980, 10980 ], \"proj:transform\": [ 10, 0, 199980, 0, -10, 3300000, 0, 0, 1 ], \"href\": \"https://sentinel-cogs.s3.us-west-2.amazonaws.com/sentinel-s2-l2a-cogs/2019/S2B_36RTT_20190830_0_L2A/TCI.tif\", \"title\": \"True color image\", \"type\": \"image/tiff; application=geotiff; profile=cloud-optimized\" }, \"SCL\": { \"proj:shape\": [ 5490, 5490 ], \"proj:transform\": [ 20, 0, 199980, 0, -20, 3300000, 0, 0, 1 ], \"href\": \"https://sentinel-cogs.s3.us-west-2.amazonaws.com/sentinel-s2-l2a-cogs/2019/S2B_36RTT_20190830_0_L2A/SCL.tif\", \"title\": \"Scene Classification Map (SCL)\", \"type\": \"image/tiff; application=geotiff; profile=cloud-optimized\" }, \"info\": { \"href\": \"https://roda.sentinel-hub.com/sentinel-s2-l2a/tiles/36/R/TT/2019/8/30/0/tileInfo.json\", \"title\": \"Original JSON metadata\", \"type\": \"application/json\" } }, \"bbox\": [ 29.896473859714554, 28.804454491507947, 31.003792553495717, 29.81537540150385 ], \"geometry\": { \"coordinates\": [ [ [ 29.92628490999458, 28.804454491507947 ], [ 29.896473859714554, 29.793998377705638 ], [ 31.003792553495717, 29.81537540150385 ], [ 30.721048631911938, 28.8202241961706 ], [ 29.92628490999458, 28.804454491507947 ] ] ], \"type\": \"Polygon\" }, \"id\": \"S2B_36RTT_20190830_0_L2A\", \"collection\": \"sentinel-s2-l2a-cogs\", \"type\": \"Feature\", \"properties\": { \"datetime\": \"2019-08-30T08:52:09Z\", \"eo:cloud_cover\": 1.96 } } In [6]: m = Map ( basemap = basemaps . OpenStreetMap . Mapnik , center = (( bounds [ 1 ] + bounds [ 3 ]) / 2 ,( bounds [ 0 ] + bounds [ 2 ]) / 2 ), zoom = 8 ) geo_json = GeoJSON ( data = data , style = { 'opacity' : 1 , 'dashArray' : '1' , 'fillOpacity' : 0 , 'weight' : 1 }, ) m . add_layer ( geo_json ) m var element = $('#0c2ede63-0ff2-4a21-8c0d-6720a33d63ab'); {\"version_major\": 2, \"version_minor\": 0, \"model_id\": \"98124e5cc52c4795b164a228bc2ce4ca\"}","title":"STAC Search"},{"location":"examples/Using-rio-tiler-mosaic/#define-the-tiler","text":"In [7]: def tiler ( asset , * args , ** kwargs ): with COGReader ( asset ) as cog : return cog . tile ( * args , ** kwargs ) In [8]: # List of z12 mercatile tile tiles = list ( mercantile . tiles ( * bounds , 12 ))","title":"Define the tiler"},{"location":"examples/Using-rio-tiler-mosaic/#firstmethod-fill-with-the-first-value-avialable","text":"In [9]: tile = tiles [ 0 ] ( tile , mask ), assets_used = mosaic_reader ( assets , tiler , tile . x , tile . y , tile . z , threads = 1 , chunk_size = 2 , ) fig = figure ( figsize = ( 30 , 10 )) ax = fig . add_subplot ( 1 , 2 , 1 ) ax . imshow ( reshape_as_image ( tile )) ax = fig . add_subplot ( 1 , 2 , 2 ) ax . imshow ( mask ) Out[9]: <matplotlib.image.AxesImage at 0x118e2a250> *{stroke-linecap:butt;stroke-linejoin:round;} In [10]: print ( assets_used ) ['https://sentinel-cogs.s3.us-west-2.amazonaws.com/sentinel-s2-l2a-cogs/2019/S2B_36RTT_20190830_0_L2A/TCI.tif']","title":"FirstMethod: Fill with the first value avialable"},{"location":"examples/Using-rio-tiler-mosaic/#meanmethod-get-the-mean-from-all-the-stack-of-data","text":"In [11]: tile = tiles [ 0 ] ( tile , mask ), assets_used = mosaic_reader ( assets , tiler , tile . x , tile . y , tile . z , pixel_selection = defaults . MeanMethod (), ) fig = figure ( figsize = ( 30 , 10 )) ax = fig . add_subplot ( 1 , 2 , 1 ) ax . imshow ( reshape_as_image ( tile )) ax = fig . add_subplot ( 1 , 2 , 2 ) ax . imshow ( mask ) Out[11]: <matplotlib.image.AxesImage at 0x119342250> *{stroke-linecap:butt;stroke-linejoin:round;} In [12]: print ( assets_used ) ['https://sentinel-cogs.s3.us-west-2.amazonaws.com/sentinel-s2-l2a-cogs/2019/S2B_36RTT_20190830_0_L2A/TCI.tif', 'https://sentinel-cogs.s3.us-west-2.amazonaws.com/sentinel-s2-l2a-cogs/2019/S2A_36RTT_20190825_0_L2A/TCI.tif', 'https://sentinel-cogs.s3.us-west-2.amazonaws.com/sentinel-s2-l2a-cogs/2019/S2B_36RTT_20190820_0_L2A/TCI.tif', 'https://sentinel-cogs.s3.us-west-2.amazonaws.com/sentinel-s2-l2a-cogs/2019/S2A_36RTT_20190815_0_L2A/TCI.tif', 'https://sentinel-cogs.s3.us-west-2.amazonaws.com/sentinel-s2-l2a-cogs/2019/S2B_36RTT_20190810_0_L2A/TCI.tif', 'https://sentinel-cogs.s3.us-west-2.amazonaws.com/sentinel-s2-l2a-cogs/2019/S2A_36RTT_20190805_0_L2A/TCI.tif', 'https://sentinel-cogs.s3.us-west-2.amazonaws.com/sentinel-s2-l2a-cogs/2019/S2A_36RTT_20190726_0_L2A/TCI.tif', 'https://sentinel-cogs.s3.us-west-2.amazonaws.com/sentinel-s2-l2a-cogs/2019/S2B_36RTT_20190721_0_L2A/TCI.tif', 'https://sentinel-cogs.s3.us-west-2.amazonaws.com/sentinel-s2-l2a-cogs/2019/S2B_36RTT_20190718_0_L2A/TCI.tif', 'https://sentinel-cogs.s3.us-west-2.amazonaws.com/sentinel-s2-l2a-cogs/2019/S2A_36RTT_20190716_0_L2A/TCI.tif', 'https://sentinel-cogs.s3.us-west-2.amazonaws.com/sentinel-s2-l2a-cogs/2019/S2B_36RTT_20190711_0_L2A/TCI.tif', 'https://sentinel-cogs.s3.us-west-2.amazonaws.com/sentinel-s2-l2a-cogs/2019/S2A_36RTT_20190706_0_L2A/TCI.tif', 'https://sentinel-cogs.s3.us-west-2.amazonaws.com/sentinel-s2-l2a-cogs/2019/S2B_36RTT_20190701_0_L2A/TCI.tif', 'https://sentinel-cogs.s3.us-west-2.amazonaws.com/sentinel-s2-l2a-cogs/2019/S2A_36RTT_20190626_0_L2A/TCI.tif', 'https://sentinel-cogs.s3.us-west-2.amazonaws.com/sentinel-s2-l2a-cogs/2019/S2B_36RTT_20190621_0_L2A/TCI.tif', 'https://sentinel-cogs.s3.us-west-2.amazonaws.com/sentinel-s2-l2a-cogs/2019/S2B_36RTT_20190618_0_L2A/TCI.tif', 'https://sentinel-cogs.s3.us-west-2.amazonaws.com/sentinel-s2-l2a-cogs/2019/S2A_36RTT_20190616_1_L2A/TCI.tif', 'https://sentinel-cogs.s3.us-west-2.amazonaws.com/sentinel-s2-l2a-cogs/2019/S2B_36RTT_20190611_0_L2A/TCI.tif', 'https://sentinel-cogs.s3.us-west-2.amazonaws.com/sentinel-s2-l2a-cogs/2019/S2A_36RTT_20190606_0_L2A/TCI.tif', 'https://sentinel-cogs.s3.us-west-2.amazonaws.com/sentinel-s2-l2a-cogs/2019/S2A_36RTT_20190603_0_L2A/TCI.tif', 'https://sentinel-cogs.s3.us-west-2.amazonaws.com/sentinel-s2-l2a-cogs/2019/S2B_36RTT_20190601_0_L2A/TCI.tif']","title":"MeanMethod: Get the mean from all the stack of data"},{"location":"examples/Using-rio-tiler-mosaic/#create-custom-pixel_selection-class","text":"","title":"Create Custom pixel_selection class"},{"location":"examples/Using-rio-tiler-mosaic/#1-using-a-4th-band-for-decision-highest-ndvi","text":"In [14]: stac_item = \"https://earth-search.aws.element84.com/v0/collections/sentinel-s2-l2a-cogs/items/ {sceneid} \" stac_assets = [ stac_item . format ( sceneid = scene ) for scene in sceneid ] In [15]: # Fisrt, let's checkout the STDEV of the NDVI values # Because we need to use multiple STAC assets, it's easier to use the STACReader def custom_tiler ( asset , * args , ** kwargs ): with STACReader ( asset ) as stac : return stac . tile ( * args , expression = \"(B08-B04)/(B08+B04)\" ) tile = tiles [ 0 ] ( tile , mask ), assets_used = mosaic_reader ( stac_assets , custom_tiler , tile . x , tile . y , tile . z , pixel_selection = defaults . StdevMethod (), threads = 1 , chunk_size = 2 , ) fig = figure ( figsize = ( 30 , 10 )) ax = fig . add_subplot ( 1 , 2 , 1 ) ax . imshow ( tile [ 0 ]) ax = fig . add_subplot ( 1 , 2 , 2 ) ax . imshow ( mask ) In [51]: # We create a custom tiler function that will read the TCI asset and add a 4th representing the NDVI def custom_tiler ( asset , * args , ** kwargs ): with STACReader ( asset ) as stac : tile , mask = stac . tile ( * args , assets = \"visual\" ) ndvi , _ = stac . tile ( * args , expression = \"(B08-B04)/(B08+B04)\" ) return numpy . concatenate (( tile , ndvi )), mask In [37]: class CustomFourthBandH ( MosaicMethodBase ): \"\"\"Feed the mosaic tile with the Mean pixel value.\"\"\" @property def data ( self ): \"\"\"Return data and mask.\"\"\" if self . tile is not None : return self . tile . data [: - 1 ], ~ self . tile . mask [ 0 ] * 255 else : return None , None def feed ( self , tile ): \"\"\"Add data to tile.\"\"\" if self . tile is None : self . tile = tile return pidex = ( numpy . bitwise_and ( tile . data [ - 1 ] > self . tile . data [ - 1 ], ~ tile . mask ) | self . tile . mask ) mask = numpy . where ( pidex , tile . mask , self . tile . mask ) self . tile = numpy . ma . where ( pidex , tile , self . tile ) self . tile . mask = mask In [57]: tile = tiles [ 0 ] ( tile , mask ), assets_used = mosaic_reader ( stac_assets [ 0 : 10 ], custom_tiler , tile . x , tile . y , tile . z , pixel_selection = CustomFourthBandH (), threads = 1 , chunk_size = 2 , ) fig = figure ( figsize = ( 30 , 10 )) ax = fig . add_subplot ( 1 , 2 , 1 ) # NOTE: because we are using NDVI + Visual, the output array, will be in float32 ax . imshow ( reshape_as_image ( tile . astype ( \"uint8\" ))) ax = fig . add_subplot ( 1 , 2 , 2 ) ax . imshow ( mask ) Out[57]: <matplotlib.image.AxesImage at 0x11c3efd10> In [ ]:","title":"1. Using a 4th band for decision: highest NDVI"}]}